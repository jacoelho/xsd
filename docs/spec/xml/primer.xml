<?xml version='1.0'?>
<!-- Id: primer.xml,v 1.11 2004/10/07 20:07:58 cmsmcq Exp  -->
<?xml-stylesheet type='text/xsl' href='xmlschema_nodiffs.xsl'?>
<!DOCTYPE spec PUBLIC "-//W3C//DTD Specification V2.2//EN" "schemaSpecs.dtd" [
   <!ENTITY suffix "">
   <!ENTITY SchemaWG "<loc
href='http://www.w3.org/XML/Activity#schema-wg'>W3C XML Schema Working Group</loc>">
 <!ENTITY part1 "http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/structures.html">
 <!ENTITY part2 "http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html">
   <!ATTLIST spec xml:lang CDATA #IMPLIED>

 <!--* entity declarations for non-validating processors who don't 
     * fetch external entities *-->
 <!ENTITY nbsp "&#xA0;" >
 ]>
<spec w3c-doctype="rec" status="final" xml:lang="en">
  <header>
    <title>XML Schema Part 0: Primer</title>
    <version diff="add">Second Edition</version>
    <w3c-designation>rec-20041028</w3c-designation>
    <w3c-doctype>W3C Recommendation</w3c-doctype>
    <pubdate>
      <day>28</day>
      <month>October</month>
      <year>2004</year><!--  Id: primer.xml,v 1.11 2004/10/07 20:07:58 cmsmcq Exp  -->
    </pubdate>
    <publoc>
      <loc href="http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/">http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/</loc>
    </publoc>
<altlocs diff="chg">
    <loc href="http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/primer.xml">XML</loc>
    <loc href="http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/primer-with-errata.html">XHTML with visible change markup</loc>
</altlocs>
<!--* We need a way to get the prescribed text:
See also <a
href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xmlschema"
><strong>translations</strong></a>.
*-->
    <latestloc>
      <loc href="http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</loc>
    </latestloc>
   <prevlocs>
      <loc href="http://www.w3.org/TR/2004/PER-xmlschema-0-20040318/">http://www.w3.org/TR/2004/PER-xmlschema-0-20040318/</loc>
   </prevlocs>
    <authlist>
     <author role="1e">
      <name>David C. Fallside</name>
      <affiliation>IBM</affiliation>
      <email href="mailto:fallside@us.ibm.com">fallside@us.ibm.com</email>
     </author>
      <author role="2e" diff="add">
        <name diff="add">Priscilla Walmsley </name>
        <email href="mailto:pwalmsley@datypic.com">pwalmsley@datypic.com</email>
      </author>
    </authlist>
<errataloc href="http://www.w3.org/2004/03/xmlschema-errata"/>
<preverrataloc href="http://www.w3.org/2001/05/xmlschema-errata"/>
<translationloc href="http://www.w3.org/2001/05/xmlschema-translations"/>
<status>
<p><emph>This section describes the status of this document at the
time of its publication. Other documents may supersede this document.
<phrase diff="chg">A list of current W3C publications and the latest
revision of this technical report can be found in the <loc
href="http://www.w3.org/TR/">W3C technical reports index</loc> at
http://www.w3.org/TR/.</phrase></emph></p>

<!--* Don't mark the next paragraph deleted: that would suggest
    * it was in the First Edition and has now been deleted. 
    * Instead, just delete it.  Or rather, comment it out
    * (in case we change our minds). 
    *-->
<!--* <p diff="del">This is a <xspecref
href="http://www.w3.org/2004/02/Process-20040205/tr.html#ProposedEditedRec">W3C
Proposed Edited Recommendation</xspecref>, intended to become the
first part of the Second Edition of XML Schema.  It is here made
available for review by W3C members and other interested parties. Note
that a Candidate Recommendation draft has not been deemed necessary by
the Working Group, as there are no substantial implementation issues
arising as a result of this edition, which aims only to incorporate
the published corrigenda to the first edition.</p> *-->

<!--* in next paragraph, the phrase 'or cited as a normative reference
    * from another document' should appear in parts 1 and 2 but not
    * in part 0. *-->
<p><phrase diff="add">This is a <xspecref
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsW3C">W3C
Recommendation</xspecref>, the first part of the Second Edition of XML
Schema.</phrase> This document has been reviewed by W3C Members and
other interested parties and has been endorsed by the Director as a
W3C Recommendation. It is a stable document and may be used as
reference material<phrase diff="del"> or cited as a normative reference 
from another document</phrase>. 
W3C's role in making the Recommendation is to draw attention
to the specification and to promote its widespread deployment. This
enhances the functionality and interoperability of the Web. 
</p>

<!--* next paragraph deleted vis-a-vis PER but not vis-a-vis 1E *-->
<!--* <p diff="del">Please send comments on this Proposed Edited
Recommendation to <loc
href="mailto:www-xml-schema-comments@w3.org">www-xml-schema-comments@w3.org</loc>,
including <code>2E PER</code> in the subject line, no later than 16
April 2004.</p> *-->

<!--* next paragraph deleted vis-a-vis PER but not vis-a-vis 1E *-->
<!--* <p diff="del">Publication as a Proposed Edited Recommendation does not
imply endorsement by the W3C Membership. This is a draft document and
may be updated, replaced or obsoleted by other documents at any
time. It is inappropriate to cite this document as other than work in
progress.</p> *-->

<p>
This document has been produced by the <loc
href="http://www.w3.org/XML/Schema">W3C XML Schema Working Group</loc>
as part of the W3C <loc href="http://www.w3.org/XML/Activity">XML
Activity</loc>. The goals of the XML Schema language are discussed in
the <loc href="http://www.w3.org/TR/NOTE-xml-schema-req">XML Schema
Requirements</loc> document. The authors of this document are the
members of the XML Schema Working Group.  Different parts of this
specification have different editors.
</p>

<p diff="del">This version of this document incorporates some editorial changes
from earlier versions.</p>
 
<!--* next paragraph deleted vis-a-vis PER but not vis-a-vis 1E *-->
<!--* <p diff="del">Documentation of intellectual property possibly relevant to this
recommendation may be found at the Working Group's <loc
role="disclosure"
href="http://www.w3.org/2002/11/xml-schema-IPR-statements.html">public
IPR disclosure page</loc>.</p> *-->

<p diff="add">
This document was produced under the <loc
href="http://www.w3.org/TR/2002/NOTE-patent-practice-20020124">24
January 2002 Current Patent Practice (CPP)</loc> as amended by the <loc
href="http://www.w3.org/2004/02/05-pp-transition">W3C Patent Policy
Transition Procedure</loc>. The Working Group maintains a <loc
role="disclosure"
href="http://www.w3.org/2002/11/xml-schema-IPR-statements.html">public
list of patent disclosures</loc> relevant to this document;
that page also includes instructions for disclosing a patent. 
An individual who
has actual knowledge of a patent which the individual believes
contains Essential Claim(s) with respect to this specification should
disclose the information in accordance with <loc
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 
6 of the W3C Patent Policy</loc>.
</p>

<p diff="del">Please report errors in this document to <loc
href="mailto:www-xml-schema-comments@w3.org">www-xml-schema-comments@w3.org</loc> 
(<loc
href="http://lists.w3.org/Archives/Public/www-xml-schema-comments/">archive</loc>). 
The list of known errors in this specification is available at <loc
href="http://www.w3.org/2001/05/xmlschema-errata">http://www.w3.org/2001/05/xmlschema-errata</loc>. 
</p>

<p>The English version of this specification is the only normative
version. Information about translations of this document is available
at <loc
href="http://www.w3.org/2001/05/xmlschema-translations">http://www.w3.org/2001/05/xmlschema-translations</loc>.</p>

<p diff="del">A list of current W3C Recommendations and other
technical documents can be found at
<loc href="http://www.w3.org/TR">http://www.w3.org/TR</loc>.</p>

<p diff="add">This second edition is <emph>not</emph> a new version,
it merely incorporates the changes dictated by the corrections to
errors found in the <loc
href="http://www.w3.org/TR/2001/REC-xmlschema-0-20010502/">first
edition</loc> as agreed by the XML Schema Working Group, as a
convenience to readers.  A separate list of all such corrections is
available at <loc
href="http://www.w3.org/2001/05/xmlschema-errata">http://www.w3.org/2001/05/xmlschema-errata</loc>. 
</p>

<p diff="add">The errata list for this second edition is available at <loc
href="http://www.w3.org/2004/03/xmlschema-errata">http://www.w3.org/2004/03/xmlschema-errata</loc>.</p>

<p diff="add">
Please report errors in this document to <loc
href="mailto:www-xml-schema-comments@w3.org">www-xml-schema-comments@w3.org</loc> 
(<loc
href="http://lists.w3.org/Archives/Public/www-xml-schema-comments/">archive</loc>).
</p>
     
</status>
<abstract>
    <p>XML Schema Part 0: Primer is a non-normative document
      intended to provide an easily readable description of the
      XML Schema facilities, and is oriented towards quickly
      understanding how to create schemas using the XML Schema
      language. <xspecref href="&part1;">XML
      Schema Part 1: Structures</xspecref> and <xspecref href="&part2;">XML
      Schema Part 2: Datatypes</xspecref> provide the complete normative
      description of the XML Schema language. This primer
      describes the language features through numerous examples
      which are complemented by extensive references to the
      normative texts.</p>
</abstract>
<sourcedesc>
  <p>Created in electronic form using XML.</p>
</sourcedesc>
<langusage>
<language id="EN">English</language>
      <language id="ebnf">Extended Backus-Naur Form (formal grammar)</language>
</langusage>
<revisiondesc>
  <slist>
   <sitem>2002-09-03: PHW: First XML version of this document</sitem>
  </slist>
</revisiondesc>
</header>
<body>

    <div1 id="Intro">
    <head>Introduction</head>
    <p>
       This document, XML Schema Part 0: Primer, provides an
      easily approachable description of the XML Schema
      definition language, and should be used alongside the
      formal descriptions of the language contained in Parts <xspecref href="&part1;">
      1</xspecref> and <xspecref href="&part2;">2</xspecref>
      of the XML Schema specification. The intended audience of
      this document includes application developers whose
      programs read and write schema documents, and schema
      authors who need to know about the features of the
      language, especially features that provide functionality
      above and beyond what is provided by DTDs. The text assumes
      that you have a basic understanding of <loc href="http://www.w3.org/TR/2000/REC-xml-20001006">XML 1.0</loc> and <phrase diff="add"><loc href="http://www.w3.org/TR/1999/REC-xml-names-19990114/">Namespaces in XML</loc></phrase><phrase diff="del"><loc href="http://www.w3.org/TR/1999/REC-xml-names-19990114/">XML-Namespaces</loc></phrase>.
      Each major section of the primer introduces new features of
      the language, and describes those features in the context
      of concrete examples.
    </p>
    <p>
       <specref ref="PO"/> covers the basic mechanisms of
      XML Schema. It describes how to declare the elements and
      attributes that appear in XML documents, the distinctions
      between simple and complex types, defining complex types,
      the use of simple types for element and attribute values,
      schema annotation, a simple mechanism for re-using element
      and attribute definitions, and nil values.
    </p>
    <p>
       <specref ref="NS"/>, the first advanced section in
      the primer, explains the basics of how namespaces are used
      in XML and schema documents. This section is important for
      understanding many of the topics that appear in the other
      advanced sections.
    </p>
    <p>
       <specref ref="IPO"/>, the second advanced section
      in the primer, describes mechanisms for deriving types from
      existing types, and for controlling these derivations. The
      section also describes mechanisms for merging together
      fragments of a schema from multiple sources, and for
      element substitution.
    </p>
    <p>
       <specref ref="quartelyReport"/> covers more
      advanced features, including a mechanism for specifying
      uniqueness among attributes and elements, a mechanism for
      using types across namespaces, a mechanism for extending
      types based on namespaces, and a description of how
      documents are checked for conformance.
    </p>
    <p>
       In addition to the sections just described, the primer
      contains a number of appendices that
      provide detailed reference information on simple types and
      a regular expression language.
    </p>
    <p>
       The primer is a non-normative document, which means that
      it does not provide a definitive (from the W3C's point of
      view) specification of the XML Schema language. The
      examples and other explanatory material in this document
      are provided to help you understand XML Schema, but they
      may not always provide definitive answers. In such cases,
      you will need to refer to the XML Schema specification, and
      to help you do this, we provide many links pointing to the
      relevant parts of the specification. More specifically, XML
      Schema items mentioned in the primer text are linked to an
      index [<specref ref="index"/>] of element names and attributes,
      and a summary <loc href="#simpleTypesTable">table</loc> of
      datatypes, both in the primer. The table and the index
      contain links to the relevant sections of XML Schema parts
      1 and 2.
    </p>
</div1>
<div1 id="PO"><head>Basic Concepts: The Purchase Order</head>
    <p>
       The purpose of a schema is to define a class of XML
      documents, and so the term "instance document" is often
      used to describe an XML document that conforms to a
      particular schema. In fact, neither instances nor schemas
      need to exist as documents <emph>per se</emph> -- they may
      exist as streams of bytes sent between applications, as
      fields in a database record, or as collections of XML
      Infoset "Information Items" -- but to simplify the primer,
      we have chosen to always refer to instances and schemas as
      if they are documents and files.
    </p>
    <p>
       Let us start by considering an instance document in a file
      called <code><loc href="#po.xml">po.xml</loc></code>. It
      describes a purchase order generated by a home products
      ordering and billing application:
    </p>
<note role="example" id="po.xml"><p>The Purchase Order, po.xml</p>
<eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;purchaseOrder orderDate="1999-10-20"&gt;
   &lt;shipTo country="US"&gt;
      &lt;name&gt;Alice Smith&lt;/name&gt;
      &lt;street&gt;123 Maple Street&lt;/street&gt;
      &lt;city&gt;Mill Valley&lt;/city&gt;
      &lt;state&gt;CA&lt;/state&gt;
      &lt;zip&gt;90952&lt;/zip&gt;
   &lt;/shipTo&gt;
   &lt;billTo country="US"&gt;
      &lt;name&gt;Robert Smith&lt;/name&gt;
      &lt;street&gt;8 Oak Avenue&lt;/street&gt;
      &lt;city&gt;Old Town&lt;/city&gt;
      &lt;state&gt;PA&lt;/state&gt;
      &lt;zip&gt;95819&lt;/zip&gt;
   &lt;/billTo&gt;
   &lt;comment&gt;Hurry, my lawn is going wild&lt;!/comment&gt;
   &lt;items&gt;
      &lt;item partNum="872-AA"&gt;
         &lt;productName&gt;Lawnmower&lt;/productName&gt;
         &lt;quantity&gt;1&lt;/quantity&gt;
         &lt;USPrice&gt;148.95&lt;/USPrice&gt;
         &lt;comment&gt;Confirm this is electric&lt;/comment&gt;
      &lt;/item&gt;
      &lt;item partNum="926-AA"&gt;
         &lt;productName&gt;Baby Monitor&lt;/productName&gt;
         &lt;quantity&gt;1&lt;/quantity&gt;
         &lt;USPrice&gt;39.98&lt;/USPrice&gt;
         &lt;shipDate&gt;1999-05-21&lt;/shipDate&gt;
      &lt;/item&gt;
   &lt;/items&gt;
&lt;/purchaseOrder&gt;
</eg>
</note>
    <p>
       The purchase order consists of a main element, <code>
      purchaseOrder</code>, and the subelements <code>
      shipTo</code>, <code>billTo</code>, <code>comment</code>,
      and <code>items</code>. These subelements (except <code>
      comment</code>) in turn contain other subelements, and so
      on, until a subelement such as <code>USPrice</code>
      contains a number rather than any subelements. Elements
      that contain subelements or carry attributes are said to
      have complex types, whereas elements that contain numbers
      (and strings, and dates, etc.) but do not contain any
      subelements are said to have simple types. Some elements
      have attributes; attributes always have simple types.
    </p>
    <p>
       The complex types in the instance document, and some of
      the simple types, are defined in the schema for purchase
      orders. The other simple types are defined as part of XML
      Schema's repertoire of built-in simple types.
    </p>
    <p>
       Before going on to examine the purchase order schema, we
      digress briefly to mention the association between the
      instance document and the purchase order schema. As you can
      see by inspecting the instance document, the purchase order
      schema is not mentioned. An instance is not actually
      required to reference a schema, and although many will, we
      have chosen to keep this first section simple, and to
      assume that any processor of the instance document can
      obtain the purchase order schema without any information
      from the instance document. In later sections, we will
      introduce explicit mechanisms for associating instances and
      schemas.
    </p>
    <div2 id="POSchema"><head>The Purchase Order Schema</head>
    <p>
       The purchase order schema is contained in the file <code>
      <loc href="#po.xsd">po.xsd</loc></code>:
    </p>
<note id="po.xsd" role="example"><p>The Purchase Order Schema, po.xsd</p>
<eg xml:space="preserve">
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;

  &lt;xsd:annotation&gt;
    &lt;xsd:documentation xml:lang="en"&gt;
     Purchase order schema for Example.com.
     Copyright 2000 Example.com. All rights reserved.
    &lt;/xsd:documentation&gt;
  &lt;/xsd:annotation&gt;

  &lt;xsd:element name="purchaseOrder" type="PurchaseOrderType"/&gt;

  &lt;xsd:element name="comment" type="xsd:string"/&gt;

  &lt;xsd:complexType name="PurchaseOrderType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="shipTo" type="USAddress"/&gt;
      &lt;xsd:element name="billTo" type="USAddress"/&gt;
      &lt;xsd:element ref="comment" minOccurs="0"/&gt;
      &lt;xsd:element name="items"  type="Items"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="orderDate" type="xsd:date"/&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="USAddress"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="name"   type="xsd:string"/&gt;
      &lt;xsd:element name="street" type="xsd:string"/&gt;
      &lt;xsd:element name="city"   type="xsd:string"/&gt;
      &lt;xsd:element name="state"  type="xsd:string"/&gt;
      &lt;xsd:element name="zip"    type="xsd:decimal"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="country" type="xsd:NMTOKEN"
                   fixed="US"/&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="Items"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="item" minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xsd:complexType&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element name="productName" type="xsd:string"/&gt;
            &lt;xsd:element name="quantity"&gt;
              &lt;xsd:simpleType&gt;
                &lt;xsd:restriction base="xsd:positiveInteger"&gt;
                  &lt;xsd:maxExclusive value="100"/&gt;
                &lt;/xsd:restriction&gt;
              &lt;/xsd:simpleType&gt;
            &lt;/xsd:element&gt;
            &lt;xsd:element name="USPrice"  type="xsd:decimal"/&gt;
            &lt;xsd:element ref="comment"   minOccurs="0"/&gt;
            &lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/&gt;
          &lt;/xsd:sequence&gt;
          &lt;xsd:attribute name="partNum" type="SKU" use="required"/&gt;
        &lt;/xsd:complexType&gt;
      &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Stock Keeping Unit, a code for identifying products --&gt;
  &lt;xsd:simpleType name="SKU"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

&lt;/xsd:schema&gt;
</eg>
</note>
    <p>
       The purchase order schema consists of a <code><loc href="#element-schema">schema</loc></code> element and a variety
      of subelements, most notably <code><loc href="#element-element">element</loc></code>, <code><loc href="#element-complexType">complexType</loc></code>, and <code><loc href="#element-simpleType">simpleType</loc></code> which
      determine the appearance of elements and their content in
      instance documents.
    </p>
    <p id="ref1">Each of the elements in the schema has
      a prefix <code>xsd:</code> which is associated with the XML
      Schema namespace through the declaration, <code>
      xmlns:xsd="http://www.w3.org/2001/XMLSchema"</code>,
      that appears in the <code><loc href="#element-schema">
      schema</loc></code> element. The prefix <code>xsd:</code> is
      used by convention to denote the XML Schema namespace,
      although any prefix can be used. The same prefix, and hence
      the same association, also appears on the names of built-in
      simple types, e.g. <code>xsd:<loc href="#string">string</loc></code>. The purpose of the association
      is to identify the elements and simple types as belonging
      to the vocabulary of the XML Schema language rather than
      the vocabulary of the schema author. For the sake of
      clarity in the text, we just mention the names of elements
      and simple types (e.g. <code><loc href="#element-simpleType">
      simpleType</loc></code>), and omit the prefix.
    </p>
    </div2>
    <div2 id="DefnDeclars"><head>Complex Type Definitions, Element &amp; Attribute Declarations</head>
    <p>
       In XML Schema, there is a basic difference between complex
      types which allow elements in their content and may carry
      attributes, and simple types which cannot have element
      content and cannot carry attributes. There is also a major
      distinction between definitions which create new types
      (both simple and complex), and declarations which enable
      elements and attributes with specific names and types (both
      simple and complex) to appear in document instances. In
      this section, we focus on defining complex types and
      declaring the elements and attributes that appear within
      them.
    </p>
    <p id="ref2">New complex types are defined using
      the <code><loc href="#element-complexType">
      complexType</loc></code> element and such definitions
      typically contain a set of element declarations, element
      references, and attribute declarations. The declarations
      are not themselves types, but rather an association between
      a name and the constraints which govern the appearance of that
      name in documents governed by the associated schema.
      Elements are declared using the <code><loc href="#element-element">element</loc></code> element, and
      attributes are declared using the <code><loc href="#element-attribute">attribute</loc></code> element. For
      example, <code>USAddress</code> is defined as a complex
      type, and within the definition of <code>USAddress</code>
      we see five element declarations and one attribute
      declaration:
    </p>
<note id="DefiningtheUSAddressType" role="example"><p>Defining the USAddress Type</p>
<eg xml:space="preserve">
&lt;xsd:complexType name="USAddress" &gt;
  &lt;xsd:sequence&gt;
    &lt;xsd:element name="name"   type="xsd:string"/&gt;
    &lt;xsd:element name="street" type="xsd:string"/&gt;
    &lt;xsd:element name="city"   type="xsd:string"/&gt;
    &lt;xsd:element name="state"  type="xsd:string"/&gt;
    &lt;xsd:element name="zip"    type="xsd:decimal"/&gt;
  &lt;/xsd:sequence&gt;
  &lt;xsd:attribute name="country" type="xsd:NMTOKEN" fixed="US"/&gt;
&lt;/xsd:complexType&gt;
</eg>
</note>
    <p id="ref3">The consequence of this definition is
      that any element appearing in an instance whose type is
      declared to be <code>USAddress</code> (e.g. <code>
      shipTo</code> in <code> <loc href="#po.xml">
      po.xml</loc></code>) must consist of five elements and one
      attribute. These elements must be called <code>name</code>,
      <code>street</code>, <code> city</code>, <code>state</code>
      and <code>zip</code> as specified by the values of the
      declarations' <code>name</code> attributes, and the
      elements must appear in the same sequence (order) in which
      they are declared. The first four of these elements will
      each contain a string, and the fifth will contain a
      number. The element whose type is declared to be <code>
      USAddress</code> may appear with an attribute called <code>
      country</code> which must contain the string <code>
      US</code>.
    </p>
    <p id="ref4">The <code>USAddress</code> definition
      contains only declarations involving the simple types: <code><loc href="#string">string</loc></code>, <code><loc href="#decimal">
      decimal</loc></code> and <code><loc href="#NMTOKEN">
      NMTOKEN</loc></code>. In contrast, the <code>
      PurchaseOrderType</code> definition contains element
      declarations involving complex types, e.g. <code>
      USAddress</code>, although note that both declarations use
      the same <code><loc href="#attribute-type">type</loc></code>
      attribute to identify the type, regardless of whether the
      type is simple or complex.
    </p>
<note id="DefiningPurchaseOrderType" role="example"><p>Defining PurchaseOrderType</p>
<eg xml:space="preserve">
&lt;xsd:complexType name="PurchaseOrderType"&gt;
  &lt;xsd:sequence&gt;
    &lt;xsd:element name="shipTo" type="USAddress"/&gt;
    &lt;xsd:element name="billTo" type="USAddress"/&gt;
    &lt;xsd:element ref="comment" minOccurs="0"/&gt;
    &lt;xsd:element name="items"  type="Items"/&gt;
  &lt;/xsd:sequence&gt;
  &lt;xsd:attribute name="orderDate" type="xsd:date"/&gt;
&lt;/xsd:complexType&gt;
</eg>
</note>
    <p>
       In defining <code>PurchaseOrderType</code>, two of the
      element declarations, for <code>shipTo</code> and <code>
      billTo</code>, associate different element names with the
      same complex type, namely <code>USAddress</code>. The
      consequence of this definition is that any element
      appearing in an instance document (e.g. <code><loc href="#po.xml">
      po.xml</loc></code>) whose type is declared to be <code>
      PurchaseOrderType</code> must consist of elements named
      <code>shipTo</code> and <code> billTo,</code> each
      containing the five subelements (<code>name</code>, <code>
      street</code>, <code>city</code>, <code>state</code> and
      <code>zip</code>) that were declared as part of <code>
      USAddress</code>. The <code>shipTo</code> and <code>
      billTo</code> elements may also carry the <code>
      country</code> attribute that was declared as part of
      <code>USAddress</code>.
    </p>
    <p>
       The <code>PurchaseOrderType</code> definition contains an
      <code>orderDate</code> attribute declaration which, like
      the <code>country</code> attribute declaration, identifies
      a simple type. In fact, all attribute declarations must
      reference simple types because, unlike element
      declarations, attributes cannot contain other elements or
      other attributes.
    </p>
    <p id="ref5">The element declarations we have
      described so far have each associated a name with an
      existing type definition. Sometimes it is preferable to use
      an existing element rather than declare a new element, for
      example:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;xsd:element ref="comment" minOccurs="0"/&gt;
</eg>
</note>
    <p>
       This declaration references an existing element, <code>
      comment</code>, that was declared elsewhere in the purchase
      order schema. In general, the value of the <code><loc href="#attribute-ref">ref</loc></code> attribute must reference a
      global element, i.e. one that has been declared under
      <code><loc href="#element-schema">schema</loc></code> rather
      than as part of a complex type definition. The consequence
      of this declaration is that an element called <code>
      comment</code> may appear in an instance document, and its
      content must be consistent with that element's type, in
      this case, <code><loc href="#string">string</loc></code>.
    </p>
    <div3 id="OccurrenceConstraints"><head>Occurrence Constraints</head>
    <p id="ref6">The <code>comment</code> element is
      optional within <code> PurchaseOrderType</code> because the
      value of the <code><loc href="#attribute-minOccurs">
      minOccurs</loc></code> attribute in its declaration is 0. In
      general, an element is required to appear when the value of
      <code><loc href="#attribute-minOccurs">minOccurs</loc></code>
      is 1 or more. The maximum number of times an element may
      appear is determined by the value of a <code><loc href="#attribute-maxOccurs">maxOccurs</loc></code> attribute in
      its declaration. This value may be a positive integer such
      as 41, or the term <code>unbounded</code> to indicate there
      is no maximum number of occurrences. The default value for
      both the <code><loc href="#attribute-minOccurs">
      minOccurs</loc></code> and the <code><loc href="#attribute-maxOccurs">maxOccurs</loc></code> attributes is
      1. Thus, when an element such as <code>comment</code> is
      declared without a <code> <loc href="#attribute-maxOccurs">
      maxOccurs</loc></code> attribute, the element may not occur
      more than once. Be sure that if you specify a value for
      only the <code><loc href="#attribute-minOccurs">
      minOccurs</loc></code> attribute, it is less than or equal to
      the default value of <code><loc href="#attribute-maxOccurs">
      maxOccurs</loc></code>, i.e. it is 0 or 1. Similarly, if you
      specify a value for only the <code><loc href="#attribute-maxOccurs">maxOccurs</loc></code> attribute, it
      must be greater than or equal to the default value of
      <code><loc href="#attribute-minOccurs">minOccurs</loc></code>,
      i.e. 1 or more. If both attributes are omitted, the element
      must appear exactly once.
    </p>
    <p id="ref36">Attributes may appear once or not at
      all, but no other number of times, and so the
      syntax for specifying
      occurrences of attributes is different than the syntax for
      elements. In particular, attributes can be declared with a
      <code><loc href="#attribute-use">use</loc></code> attribute
      to indicate whether the attribute is <code>
      required</code> (see for example, the <code>partNum</code>
      attribute declaration in <code><loc href="#po.xsd">
      po.xsd</loc></code>), <code>optional</code>, or even
      <code>prohibited</code>.
    </p>
    <p>
      Default values of both attributes and elements are declared using the
      <code>default</code> attribute, although this attribute has a slightly
      different consequence in each case. When an attribute is declared with a
      default value, the value of the attribute is whatever value
      appears as the attribute's value in an instance document; if
      the attribute does not appear in the instance document, the schema
      processor provides the attribute with a value equal to that of the
      <code><loc href="#attribute-attr-default"> default</loc></code> attribute.
      Note that default values for attributes only make sense if the
      attributes themselves are optional, and so it is an error to specify
      both a default value and anything other than a value of
      <code>optional</code> for <code> <loc href="#attribute-use">use</loc></code>.
    </p>
    <p>
      The schema processor treats defaulted elements slightly differently.
      When an element is declared with a default value, the value of the
      element is whatever value appears as the element's content in the
      instance document; if the element appears without any content, the
      schema processor provides the element with a value equal to that of the
      <code><loc href="#attribute-attr-default">default</loc></code> attribute.
      However, if the element does not appear in the instance document, the schema
      processor does not provide the element at all. In summary, the
      differences between element and attribute defaults can be stated as:
      Default attribute values apply when attributes are missing, and default
      element values apply when elements are empty.
    </p>
    <p id="ref55">
      The <code>fixed</code> attribute is used in both attribute and element
      declarations to ensure that the attributes and elements are
      set to particular values. For example, <code><loc href="#po.xsd">po.xsd
      </loc></code> contains a declaration for the <code>country</code>
      attribute, which is declared with a <code><loc href="#attribute-attr-fixed">fixed</loc></code> value <code>US</code>. This
      declaration means that the appearance of a <code>country</code>
      attribute in an instance document is optional (the default value of <code>
      <loc href="#attribute-use">use</loc></code> is <code>optional</code>),
      although if the attribute does appear, its value must be <code>US</code>,
      and if the attribute does not appear, the schema processor will provide
      a <code>country</code> attribute with the value <code>US</code>. Note
      that the concepts of a fixed value and a default value are mutually
      exclusive, and so it is an error for a declaration to contain both
      <code>fixed</code> and <code>default</code> attributes.
    </p>
    <p>
       The values of the attributes used in element and attribute
      declarations to constrain their occurrences are summarized in
      <loc href="#cardinalityTable">Table 1</loc>.
    </p>
    <table id="cardinalityTable" border="2" width="100%" summary="occurrence constraints">
      <tbody>
        <tr>
          <th align="left" colspan="3">Table 1. Occurrence Constraints for Elements and Attributes</th>
        </tr>
        <tr>
          <th>
            <table border="0"><tbody>
              <tr><th>Elements</th></tr>
              <tr><th>(<loc href="#attribute-minOccurs">minOccurs</loc>, <loc href="#attribute-maxOccurs">maxOccurs</loc>)</th></tr>
              <tr><th><loc href="#attribute-fixed">fixed</loc>, <loc href="#attribute-default">default</loc></th></tr>
            </tbody></table>
          </th>
          <th>
            <table border="0"><tbody>
              <tr><th>Attributes</th></tr>
              <tr><th><loc href="#attribute-use">use</loc>, <loc href="#attribute-attr-fixed">fixed</loc>, <loc href="#attribute-attr-default">default</loc></th></tr>
            </tbody></table>
          </th>
          <th>Notes</th>
        </tr>
        <tr>
          <td align="center">(1, 1) -, -</td>
          <td align="center">required, -, -</td>
          <td>element/attribute must appear once, it may have any value</td>
        </tr>
        <tr>
          <td align="center">(1, 1) 37, -</td>
          <td align="center">required, 37, -</td>
          <td>element/attribute must appear once, its value must be 37</td>
        </tr>
        <tr>
          <td align="center">(2, unbounded) 37, -</td>
          <td align="center">n/a</td>
          <td>element must appear twice or more, its value must be
            37; in general, <loc href="#attribute-minOccurs">
            minOccurs</loc> and <loc href="#attribute-maxOccurs">
            maxOccurs</loc> values may be positive integers, and
            <loc href="#attribute-maxOccurs">maxOccurs</loc> value
            may also be "unbounded"</td>
        </tr>
        <tr>
          <td align="center">(0, 1) -, -</td>
          <td align="center">optional, -, -</td>
          <td>element/attribute may appear once, it may have any value</td>
        </tr>
        <tr>
          <td align="center"><phrase diff="add">(0, 1) 37, -</phrase></td>
          <td align="center"><phrase diff="add">n/a</phrase></td>
          <td><phrase diff="add">element may appear once, if it does not
            appear it is not provided; if it does appear and it is empty, its
            value is 37; if it does appear and it is not empty,
            its value must be 37</phrase></td>
        </tr>
        <tr>
          <td align="center"><phrase diff="del">(0, 1) 37, -</phrase><phrase diff="add">n/a</phrase></td>
          <td align="center">optional, 37, -</td>
          <td><phrase diff="del">element/</phrase>attribute may appear once, if it does appear
            its value must be 37, if it does not appear its value is 37</td>
        </tr>
        <tr>
          <td align="center"><phrase diff="add">(0, 1) -, 37</phrase></td>
          <td align="center"><phrase diff="add">n/a</phrase></td>
          <td><phrase diff="add">element may appear once; if it does not
            appear it is not provided; if it does
            appear and it is empty, its value is 37; otherwise its value is that
            given</phrase></td>
        </tr>
        <tr>
          <td align="center"><phrase diff="del">(0, 1) -, 37</phrase><phrase diff="add">n/a</phrase></td>
          <td align="center">optional, -, 37</td>
          <td><phrase diff="del">element/</phrase>attribute may appear once; if it does not
            appear its value is 37, otherwise its value is that given</td>
        </tr>
        <tr>
          <td align="center">(0, 2) -, 37</td>
          <td align="center">n/a</td>
          <td>element may appear once, twice, or not at all; if the
            element does not appear it is not provided; if it does
            appear and it is empty, its value is 37; otherwise its
            value is that given; in general, <loc href="#attribute-minOccurs">minOccurs</loc> and <loc href="#attribute-maxOccurs">maxOccurs</loc> values may be
            positive integers, and <loc href="#attribute-maxOccurs">maxOccurs</loc> value may also
            be "unbounded"</td>
        </tr>
        <tr>
          <td align="center">(0, 0) -, -</td>
          <td align="center">prohibited, -, -</td>
          <td>element/attribute must not appear</td>
        </tr>
        <tr>
          <td colspan="3">
            Note that neither <loc href="#attribute-minOccurs">
            minOccurs</loc>, <loc href="#attribute-maxOccurs">
            maxOccurs</loc>, nor <loc href="#attribute-use">use</loc>
            may appear in the declarations of global elements and
            attributes.</td>
        </tr>
      </tbody>
    </table>
    </div3>
    <div3 id="Globals"><head>Global Elements &amp; Attributes</head>
    <p>
       Global elements, and global attributes, are created by
      declarations that appear as the children of the <code><loc href="#element-schema">schema</loc></code> element. Once
      declared, a global element or a global attribute can be
      referenced in one or more declarations using the <code><loc href="#attribute-ref">ref</loc></code> attribute as described
      above. A declaration that references a global element
      enables the referenced element to appear in the instance
      document in the context of the referencing declaration. So, for
      example, the <code>comment</code> element appears in <code>
      <loc href="#po.xml">po.xml</loc></code> at the same level as
      the <code>shipTo</code>, <code>billTo</code> and <code>
      items</code> elements because the declaration that
      references <code>comment</code> appears in the complex type
      definition at the same level as the declarations of the
      other three elements.
    </p>
    <p>
       The declaration of a global element also enables the
      element to appear at the top-level of an instance document.
      Hence <code>purchaseOrder</code>, which is declared as a
      global element in <code><loc href="#po.xsd">
      po.xsd</loc></code>, can appear as the top-level element in
      <code><loc href="#po.xml">po.xml</loc></code>. Note that this
      rationale will also allow a <code>comment</code> element to
      appear as the top-level element in a document like
      <code><loc href="#po.xml"> po.xml</loc></code>.
    </p>
    <p>
       There are a number of caveats concerning the use of
      global elements and attributes. One caveat is that global
      declarations cannot contain references; global declarations
      must identify simple and complex types directly. Put
      concretely, global declarations cannot contain the <code><loc href="#attribute-ref">ref</loc></code> attribute, they must
      use the <code><loc href="#attribute-type">type</loc></code>
      attribute (or, as we describe shortly, be followed by an <loc href="#InlineTypDefn">anonymous type definition</loc>). A
      second caveat is that cardinality constraints cannot be
      placed on global declarations, although they can be placed
      on local declarations that reference global declarations.
      In other words, global declarations cannot contain the
      attributes <loc href="#attribute-minOccurs">minOccurs</loc>, <loc href="#attribute-maxOccurs"> maxOccurs</loc>, or <loc href="#attribute-use">use</loc>.
    </p>
    </div3>
    <div3 id="NamingConflicts"><head>Naming Conflicts</head>
    <p>
       We have now described how to define new complex types
      (e.g. <code>PurchaseOrderType</code>), declare elements
      (e.g. <code>purchaseOrder</code>) and declare attributes
      (e.g. <code>orderDate</code>). These activities generally
      involve naming, and so the question naturally arises: What
      happens if we give two things the same name? The answer
      depends upon the two things in question, although in
      general the more similar are the two things, the more
      likely there will be a conflict.
    </p>
    <p>
       Here are some examples to illustrate when same names cause
      problems. If the two things are both types, say we define a
      complex type called USStates and a simple type called
      USStates, there is a conflict. If the two things are a type
      and an element or attribute, say we define a complex type
      called USAddress and we declare an element called USAddress,
      there is no conflict. If the two things are elements within
      different types (i.e. not global elements), say we declare
      one element called name as part of the USAddress type and a
      second element called name as part of the Item type, there
      is no conflict. (Such elements are sometimes called local
      element declarations.) Finally, if the two things are both
      types and you define one and XML Schema has defined the
      other, say you define a simple type called decimal, there
      is no conflict. The reason for the apparent contradiction
      in the last example is that the two types belong to
      different namespaces. We explore the use of namespaces
      in schema in a later section.
    </p>
    </div3></div2>
    <div2 id="CreatDt"><head>Simple Types</head>
    <p>
       The purchase order schema declares several elements and
      attributes that have simple types. Some of these simple
      types, such as <code><loc href="#string">string</loc></code>
      and <code><loc href="#decimal">decimal</loc></code>, are built
      in to XML Schema, while others are derived from the
      built-in's. For example, the <code>partNum</code> attribute
      has a type called <code>SKU</code> (Stock Keeping Unit)
      that is derived from <code><loc href="#string">
      string</loc></code>. Both built-in simple types and their
      derivations can be used in all element and attribute
      declarations. <loc href="#simpleTypesTable">Table 2</loc> lists
      all the simple types built in to XML Schema, along with
      examples of the different types.
    </p>
    <table id="simpleTypesTable" border="2" width="100%" summary="built-in simple types">
      <tbody>
        <tr>
          <th align="left" colspan="3">Table 2. Simple Types Built In to XML Schema</th>
        </tr>
        <tr>
          <th align="left">Simple Type</th>
          <th align="left">Examples (delimited by commas)</th>
          <th align="left">Notes</th>
        </tr>
        <tr>
          <td id="string"><xspecref href="&part2;#string">string</xspecref></td>
          <td>Confirm this is electric</td>
          <td> </td>
        </tr>
        <tr>
          <td id="normalizedString">
            <xspecref href="&part2;#normalizedString">normalizedString</xspecref></td>
          <td>Confirm this is electric</td>
          <td>see (3)</td>
        </tr>
        <tr>
          <td id="token"><xspecref href="&part2;#token">token</xspecref></td>
          <td>Confirm this is electric</td>
          <td>see (4)</td>
        </tr>
        <tr>
          <td id="base64Binary"><xspecref href="&part2;#base64Binary">
             base64Binary</xspecref></td>
          <td>GpM7</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td id="hexBinary"><xspecref href="&part2;#hexBinary">hexBinary</xspecref></td>
          <td>0FB7</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td id="integer"><xspecref href="&part2;#integer">integer</xspecref></td>
          <td><phrase diff="del">-126789, -1, 0, 1, 126789</phrase><phrase diff="add">...-1, 0, 1, ...</phrase></td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="positiveInteger"><xspecref href="&part2;#positiveInteger">positiveInteger</xspecref></td>
          <td><phrase diff="del">1, 126789</phrase><phrase diff="add">1, 2, ...</phrase></td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="negativeInteger"><xspecref href="&part2;#negativeInteger">
             negativeInteger</xspecref></td>
          <td><phrase diff="del">-126789, -1</phrase><phrase diff="add">... -2, -1</phrase></td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="nonNegativeInteger"><xspecref href="&part2;#nonNegativeInteger">nonNegativeInteger</xspecref></td>
          <td><phrase diff="del">0, 1, 126789</phrase><phrase diff="add">0, 1, 2, ...</phrase></td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="nonPositiveInteger"><xspecref href="&part2;#nonPositiveInteger">nonPositiveInteger</xspecref></td>
          <td><phrase diff="del">-126789, -1, 0</phrase><phrase diff="add">... -2, -1, 0</phrase></td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="long"><xspecref href="&part2;#long">long</xspecref></td>
          <td><phrase diff="del">-1, 12678967543233</phrase><phrase diff="add">-9223372036854775808, ... -1, 0, 1, ... 9223372036854775807</phrase></td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="unsignedLong"><xspecref href="&part2;#unsignedLong">unsignedLong</xspecref></td>
          <td><phrase diff="del">0, 12678967543233</phrase><phrase diff="add">0, 1, ... 18446744073709551615</phrase></td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="int"><xspecref href="&part2;#int">int</xspecref></td>
          <td><phrase diff="del">-1, 126789675</phrase><phrase diff="add">-2147483648, ... -1, 0, 1, ... 2147483647</phrase></td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="unsignedInt"><xspecref href="&part2;#unsignedInt">unsignedInt</xspecref></td>
          <td><phrase diff="del">0, 1267896754</phrase><phrase diff="add">0, 1, ...4294967295</phrase></td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="short"><xspecref href="&part2;#short">short</xspecref></td>
          <td><phrase diff="del">-1, 12678</phrase><phrase diff="add">-32768, ... -1, 0, 1, ... 32767</phrase></td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="unsignedShort"><xspecref href="&part2;#unsignedShort">unsignedShort</xspecref></td>
          <td><phrase diff="del">0, 12678</phrase><phrase diff="add">0, 1, ... 65535</phrase></td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="byte"><xspecref href="&part2;#byte">byte</xspecref></td>
          <td><phrase diff="del">-1, 126</phrase><phrase diff="add">-128, ...-1, 0, 1, ... 127</phrase></td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="unsignedByte"><xspecref href="&part2;#unsignedByte">unsignedByte</xspecref></td>
          <td><phrase diff="del">0, 126</phrase><phrase diff="add">0, 1, ... 255</phrase></td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="decimal"><xspecref href="&part2;#decimal">decimal</xspecref></td>
          <td>-1.23, 0, 123.4, 1000.00</td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="float"><xspecref href="&part2;#float">float</xspecref></td>
          <td>-INF, -1E4, -0, 0, 12.78E-2, 12, INF, NaN</td>
          <td>equivalent to single-precision 32-bit floating point, NaN is "not a number", see (2)</td>
        </tr>
        <tr>
          <td id="double"><xspecref href="&part2;#double">double</xspecref></td>
          <td>-INF, -1E4, -0, 0, 12.78E-2, 12, INF, NaN</td>
          <td>equivalent to double-precision 64-bit floating point, see (2)</td>
        </tr>
        <tr>
          <td id="boolean"><xspecref href="&part2;#boolean">boolean</xspecref></td>
          <td>true, false, 1, 0</td>
          <td></td>
        </tr>
        <tr>
          <td id="duration"><xspecref href="&part2;#duration">duration</xspecref></td>
          <td>P1Y2M3DT10H30M12.3S</td>
          <td>1 year, 2 months, 3 days, 10 hours, 30 minutes, and 12.3 seconds</td>
        </tr>
        <tr>
          <td id="dateTime"><xspecref href="&part2;#dateTime">dateTime</xspecref></td>
          <td>1999-05-31T13:20:00.000-05:00</td>
          <td>May 31st 1999 at 1.20pm Eastern Standard Time which
            is 5 hours behind Co-Ordinated Universal Time, see
            (2)</td>
        </tr>
        <tr>
          <td id="date"><xspecref href="&part2;#date">date</xspecref></td>
          <td>1999-05-31</td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="time"><xspecref href="&part2;#time">time</xspecref></td>
          <td>13:20:00.000, 13:20:00.000-05:00</td>
          <td>see (2)</td>
        </tr>
        <tr>
          <td id="gYear"><xspecref href="&part2;#gYear">
             gYear</xspecref></td>
          <td>1999</td>
          <td>1999, see (2) (5)</td>
        </tr>
        <tr>
          <td id="gYearMonth"><xspecref href="&part2;#gYearMonth">gYearMonth</xspecref></td>
          <td>1999-02</td>
          <td>the month of February 1999, regardless of the number of days, see (2) (5)</td>
        </tr>
        <tr>
          <td id="gMonth"><xspecref href="&part2;#gMonth">gMonth</xspecref></td>
          <td>--05<phrase diff="del">--</phrase></td>
          <td>May, see (2) (5)</td>
        </tr>
        <tr>
          <td id="gMonthDay"><xspecref href="&part2;#gMonthDay">gMonthDay</xspecref></td>
          <td>--05-31</td>
          <td>every May 31st, see (2) (5)</td>
        </tr>
        <tr>
          <td id="gDay">
            <xspecref href="&part2;#gDay">gDay</xspecref></td>
          <td>---31</td>
          <td>the 31st day, see (2) (5)</td>
        </tr>
        <tr>
          <td id="Name"><xspecref href="&part2;#Name">Name</xspecref></td>
          <td>shipTo</td>
          <td>XML 1.0 Name type</td>
        </tr>
        <tr>
          <td id="QName"><xspecref href="&part2;#QName">QName</xspecref></td>
          <td>po:USAddress</td>
          <td>XML Namespace QName</td>
        </tr>
        <tr>
          <td id="NCName"><xspecref href="&part2;#NCName">NCName</xspecref></td>
          <td>USAddress</td>
          <td>XML Namespace NCName, i.e. a QName without the prefix and colon</td>
        </tr>
        <tr>
          <td id="anyURI"><xspecref href="&part2;#anyURI">anyURI</xspecref></td>
          <td><!--get around limitation that td can't contain br-->
            <table border="0"><tbody>
              <tr><td>http://www.example.com/,</td></tr>
              <tr><td>http://www.example.com/doc.html#ID5</td></tr>
            </tbody></table>
          </td>
          <td></td>
        </tr>
        <tr>
          <td id="language"><xspecref href="&part2;#language">language</xspecref></td>
          <td>en-GB, en-US, fr</td>
          <td>valid values for xml:lang as defined in XML 1.0</td>
        </tr>
        <tr>
          <td id="ID"><xspecref href="&part2;#ID">ID</xspecref></td>
          <td></td>
          <td>XML 1.0 ID attribute type, see (1)</td>
        </tr>
        <tr>
          <td id="IDREF"><xspecref href="&part2;#IDREF">IDREF</xspecref></td>
          <td></td>
          <td>XML 1.0 IDREF attribute type, see (1)</td>
        </tr>
        <tr>
          <td id="IDREFS"><xspecref href="&part2;#IDREFS">IDREFS</xspecref></td>
          <td></td>
          <td>XML 1.0 IDREFS attribute type, see (1)</td>
        </tr>
        <tr>
          <td id="ENTITY"><xspecref href="&part2;#ENTITY">ENTITY</xspecref></td>
          <td></td>
          <td>XML 1.0 ENTITY attribute type, see (1)</td>
        </tr>
        <tr>
          <td id="ENTITIES"><xspecref href="&part2;#ENTITIES">ENTITIES</xspecref></td>
          <td></td>
          <td>XML 1.0 ENTITIES attribute type, see (1)</td>
        </tr>
        <tr>
          <td id="NOTATION"><xspecref href="&part2;#NOTATION">NOTATION</xspecref></td>
          <td></td>
          <td>XML 1.0 NOTATION attribute type, see (1)</td>
        </tr>
        <tr>
          <td id="NMTOKEN"><xspecref href="&part2;#NMTOKEN">NMTOKEN</xspecref></td>
          <td><!--get around limitation that td can't contain br-->
            <table border="0"><tbody>
              <tr><td>US,</td></tr>
              <tr><td>Br&#xE9;sil</td></tr>
            </tbody></table>
          </td>
          <td>XML 1.0 NMTOKEN attribute type, see (1)</td>
        </tr>
        <tr>
          <td id="NMTOKENS"><xspecref href="&part2;#NMTOKENS">NMTOKENS</xspecref></td>
          <td><!--get around limitation that td can't contain br-->
            <table border="0"><tbody>
              <tr><td>US UK,</td></tr>
              <tr><td>Br&#xE9;sil Canada Mexique</td></tr>
            </tbody></table>
          </td>
          <td>XML 1.0 NMTOKENS attribute type, i.e. a whitespace
            separated list of NMTOKEN's, see (1)</td>
        </tr>
        <tr>
          <td colspan="3">
            Notes: (1) To retain compatibility
            between XML Schema and XML 1.0 DTDs, the simple types
            ID, IDREF, IDREFS, ENTITY, ENTITIES, NOTATION,
            NMTOKEN, NMTOKENS should only be used in attributes.
            (2) A value of this type can be represented by more
            than one lexical format, e.g. 100 and 1.0E2 are both
            valid float formats representing "one hundred".
            However, rules have been established for this type
            that define a canonical lexical format, see <xspecref href="&part2;#canonical-lexical-representation">
             XML Schema Part 2</xspecref>. (3) Newline, tab and
            carriage-return characters in a normalizedString type are
            converted to space characters before schema
            processing. (4) As normalizedString, and adjacent space
            characters are collapsed to a single space character,
            and leading and trailing spaces are removed. (5) The "g"
            prefix signals time periods in the Gregorian <phrase diff="del">calender</phrase><phrase diff="add">calendar</phrase>.</td>
        </tr>
      </tbody>
    </table>
    <p id="ref7">New simple types are defined by
      deriving them from existing simple types (built-in's and
      derived). In particular, we can derive a new simple type by
      restricting an existing simple type, in other words, the
      legal range of values for the new type are a subset of the
      existing type's range of values. We use the <code><loc href="#element-simpleType">simpleType</loc></code> element to
      define and name the new simple type. We use the <code><loc href="#element-restriction">restriction</loc></code> element
      to indicate the existing (base) type, and to identify the
      "facets" that constrain the range of values. A complete
      list of facets is provided in <loc href="#SimpleTypeFacets">
      Appendix B</loc>.
    </p>
    <p id="ref8">Suppose we wish to create a new type
      of integer called <code>myInteger</code> whose range of
      values is between 10000 and 99999 (inclusive). We base our
      definition on the built-in simple type <code><loc href="#integer">integer</loc></code>, whose range of values also
      includes integers less than 10000 and greater than 99999.
      To define <code>myInteger</code>, we restrict the range of
      the <code><loc href="#integer">integer</loc></code> base type
      by employing two facets called <code><loc href="#element-minInclusive">minInclusive</loc></code> and <code>
      <loc href="#element-maxInclusive">maxInclusive</loc></code>:
    </p>
<note id="DefiningmyInteger" role="example"><p>Defining myInteger, Range 10000-99999</p>
<eg xml:space="preserve">
&lt;xsd:simpleType name="myInteger"&gt;
  &lt;xsd:restriction base="xsd:integer"&gt;
    &lt;xsd:minInclusive value="10000"/&gt;
    &lt;xsd:maxInclusive value="99999"/&gt;
  &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</eg>
</note>
    <p>
       The example shows one particular combination of a base
      type and two facets used to define <code>myInteger</code>,
      but a look at the list of built-in simple types and their
      facets (<loc href="#SimpleTypeFacets">Appendix B</loc>) should
      suggest other viable combinations.
    </p>
    <p id="ref9">The purchase order schema contains
      another, more elaborate, example of a simple type
      definition. A new simple type called <code>SKU</code> is
      derived (by restriction) from the simple type <code><loc href="#string"> string</loc></code>. Furthermore, we
      constrain the values of <code>SKU</code> using a facet
      called <code><loc href="#element-pattern">pattern</loc></code>
      in conjunction with the regular expression
      "<code>\d{3}-[A-Z]{2}</code>" that is read "three digits
      followed by a hyphen followed by two upper-case ASCII
      letters":
    </p>
<note id="DefiningSKU" role="example"><p>Defining the Simple Type "SKU"</p>
<eg xml:space="preserve">
&lt;xsd:simpleType name="SKU"&gt;
  &lt;xsd:restriction base="xsd:string"&gt;
    &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;
  &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</eg>
</note>
    <p>
       This regular expression language is described more fully
      in <loc href="#regexAppendix">Appendix D</loc>.
    </p>
    <p id="ref10">XML Schema defines <phrase diff="add">twelve</phrase><phrase diff="del">fifteen</phrase> facets
      which are listed in <loc href="#SimpleTypeFacets"> Appendix
      B</loc>. Among these, the <code><loc href="#element-enumeration">enumeration</loc></code> facet is
      particularly useful and it can be used to constrain the
      values of almost every simple type, except the <code><loc href="#boolean">boolean</loc></code> type. The <code><loc href="#element-enumeration">enumeration</loc></code> facet limits
      a simple type to a set of distinct values. For example, we
      can use the <code> <loc href="#element-enumeration">
      enumeration</loc></code> facet to define a new simple type
      called <code>USState</code>, derived from <code> <loc href="#string">string</loc></code>, whose value must be one of the
      standard US state abbreviations:
    </p>
<note id="UsingEnumeration" role="example"><p>Using the Enumeration Facet</p>
<eg xml:space="preserve">
&lt;xsd:simpleType name="USState"&gt;
  &lt;xsd:restriction base="xsd:string"&gt;
    &lt;xsd:enumeration value="AK"/&gt;
    &lt;xsd:enumeration value="AL"/&gt;
    &lt;xsd:enumeration value="AR"/&gt;
    &lt;!-- and so on ... --&gt;
  &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</eg>
</note>
    <p>
       <code>USState</code> would be a good replacement for the
      <code><loc href="#string">string</loc></code> type currently
      used in the <code>state</code> element declaration. By
      making this replacement, the legal values of a <code>
      state</code> element, i.e. the <code> state</code>
      subelements of <code>billTo</code> and <code>
      shipTo</code>, would be limited to one of <code>AK</code>,
      <code>AL</code>, <code>AR</code>, etc. Note that the
      enumeration values specified for a particular type must be
      unique.
    </p>
    <div3 id="ListDt"><head>List Types</head>
    <p>
       XML Schema has the concept of a list type, in addition to
      the so-called atomic types that constitute most of the
      types listed in <loc href="#simpleTypesTable">Table 2</loc>.
      (Atomic types, list types, and the union types described in
      the next section are collectively called simple types.) The
      value of an atomic type is indivisible from XML Schema's
      perspective. For example, the <code><loc href="#NMTOKEN">
      NMTOKEN</loc></code> value <code>US</code> is indivisible in
      the sense that no part of <code>US</code>, such as the
      character "S", has any meaning by itself. In contrast, list
      types are comprised of sequences of atomic types and
      consequently the parts of a sequence (the "atoms")
      themselves are meaningful. For example, <code><loc href="#NMTOKENS">NMTOKENS</loc></code> is a list type, and an
      element of this type would be a white-space delimited list
      of <code><loc href="#NMTOKEN"> NMTOKEN</loc></code>'s, such as
      "US UK FR". XML Schema has three built-in list types, they
      are <code> <loc href="#NMTOKENS"> NMTOKENS</loc></code>, <code>
      <loc href="#IDREFS"> IDREFS</loc></code>, and <code> <loc href="#ENTITIES"> ENTITIES</loc></code>.
    </p>
    <p id="ref45">In addition to using the built-in
      list types, you can create new list types by derivation
      from existing atomic types. (You cannot create list types
      from existing list types, nor from complex types.) For
      example, to create a list of <code>myInteger</code>'s:
    </p>
<note id="CreatingListOfIntegers" role="example"><p>Creating a List of myInteger's</p>
<eg xml:space="preserve">
&lt;xsd:simpleType name="listOfMyIntType"&gt;
  &lt;xsd:list itemType="myInteger"/&gt;
&lt;/xsd:simpleType&gt;
</eg>
</note>
    <p>
       And an element in an instance document whose content
      conforms to <code>listOfMyIntType</code> is:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;listOfMyInt&gt;20003 15037 95977 95945&lt;/listOfMyInt&gt;
</eg>
</note>
    <p id="ref12">Several facets can be applied to list
      types: <code><loc href="#element-length">length</loc></code>,
      <code><loc href="#element-minLength">minLength</loc></code>,
      <code><loc href="#element-maxLength">maxLength</loc></code>, <phrase diff="add"><code><loc href="#element-pattern">pattern</loc></code>, </phrase>
      and <code><loc href="#element-enumeration">
      enumeration</loc></code>. For example, to define a list of
      exactly six US states (<code>SixUSStates</code>), we first
      define a new list type called <code>USStateList</code> from
      <code>USState</code>, and then we derive <code>
      SixUSStates</code> by restricting <code>USStateList</code>
      to only six items:
    </p>
<note id="ListTypeFor6States" role="example"><p>List Type for Six US States</p>
<eg xml:space="preserve">
&lt;xsd:simpleType name="USStateList"&gt;
  &lt;xsd:list itemType="USState"/&gt;
&lt;/xsd:simpleType&gt;

&lt;xsd:simpleType name="SixUSStates"&gt;
  &lt;xsd:restriction base="USStateList"&gt;
    &lt;xsd:length value="6"/&gt;
  &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</eg>
</note>
    <p>
       Elements whose type is <code>SixUSStates</code> must have
      six items, and each of the six items must be one of the
      (atomic) values of the enumerated type <code>
      USState</code>, for example:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;sixStates&gt;PA NY CA NY LA AK&lt;/sixStates&gt;
</eg>
</note>
    <p>
       Note that it is possible to derive a list type from the
      atomic type <code><loc href="#string">string</loc></code>.
      However, a <code> <loc href="#string">string</loc></code> may
      contain white space, and white space delimits the items in
      a list type, so you should be careful using
      list types whose base type is <code> <loc href="#string">
      string</loc></code>. For example, suppose we have defined a
      list type with a <code><loc href="#element-length">
      length</loc></code> facet equal to 3, and base type <code><loc href="#string">string</loc></code>, then the following 3 item
      list is legal:
    </p>
<note role="example">
<eg xml:space="preserve">
Asie Europe Afrique
</eg>
</note>
    <p>
       But the following 3 "item" list is illegal:
    </p>
<note role="example">
<eg xml:space="preserve">
Asie Europe Am&#xE9;rique Latine</eg>
</note>
    <p>
       Even though "Am&#xE9;rique Latine" may exist as a single
      string outside of the list, when it is included in the
      list, the whitespace between Am&#xE9;rique and Latine
      effectively creates a fourth item, and so the latter
      example will not conform to the 3-item list type.
    </p>
    </div3>
    <div3 id="UnionDt"><head>Union Types</head>
    <p id="ref46">Atomic types and list types enable an
      element or an attribute value to be one or more instances
      of one atomic type. In contrast, a union type enables an
      element or attribute value to be one or more instances of
      one type drawn from the union of multiple atomic and list
      types. To illustrate, we create a union type for
      representing American states as singleton letter
      abbreviations or lists of numeric codes. The <code>
      zipUnion</code> union type is built from one atomic type and
      one list type:
    </p>
<note id="UnionTypeForZipCodes" role="example"><p>Union Type for Zip Codes</p>
<eg xml:space="preserve">
&lt;xsd:simpleType name="zipUnion"&gt;
  &lt;xsd:union memberTypes="USState listOfMyIntType"/&gt;
&lt;/xsd:simpleType&gt;
</eg>
</note>
    <p>
       When we define a union type, the <code>memberTypes</code>
      attribute value is a list of all the types in the union.
    </p>
    <p>
       Now, assuming we have declared an element called <code>
      zips</code> of type <code>zipUnion</code>, valid instances
      of the element are:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;zips&gt;CA&lt;/zips&gt;
&lt;zips&gt;95630 95977 95945&lt;/zips&gt;
&lt;zips&gt;AK&lt;/zips&gt;
</eg>
</note>
    <p>
       Two facets, <code><loc href="#element-pattern">
      pattern</loc></code> and <code><loc href="#element-enumeration">enumeration</loc></code>, can be
      applied to a union type.
    </p>
    </div3></div2>
    <div2 id="InlineTypDefn"><head>Anonymous Type Definitions</head>
    <p>
       Schemas can be constructed by defining sets of named types
      such as <code>PurchaseOrderType</code> and then declaring
      elements such as <code>purchaseOrder</code> that reference
      the types using the <code><loc href="#attribute-type">
      type</loc>=</code> construction. This style of schema
      construction is straightforward but it can be unwieldy,
      especially if you define many types that are referenced
      only once and contain very few constraints. In these cases,
      a type can be more succinctly defined as an anonymous type
      which saves the overhead of having to be named and
      explicitly referenced.
    </p>
    <p>
       The definition of the type <code>Items</code> in <code> <loc href="#po.xsd">po.xsd</loc></code> contains two element
      declarations that use anonymous types (<code>item</code>
      and <code> quantity</code>). In general, you can identify
      anonymous types by the lack of a <code><loc href="#attribute-type">type</loc>=</code> in an element (or
      attribute) declaration, and by the presence of an un-named
      (simple or complex) type definition:
    </p>
<note id="TwoAnonymousTypeDefinitions" role="example"><p>Two Anonymous Type Definitions</p>
<eg xml:space="preserve">
&lt;xsd:complexType name="Items"&gt;
  &lt;xsd:sequence&gt;
    &lt;xsd:element name="item" minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xsd:complexType&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="productName" type="xsd:string"/&gt;
          &lt;xsd:element name="quantity"&gt;
            &lt;xsd:simpleType&gt;
              &lt;xsd:restriction base="xsd:positiveInteger"&gt;
                &lt;xsd:maxExclusive value="100"/&gt;
              &lt;/xsd:restriction&gt;
            &lt;/xsd:simpleType&gt;
          &lt;/xsd:element&gt;
          &lt;xsd:element name="USPrice"  type="xsd:decimal"/&gt;
          &lt;xsd:element ref="comment"   minOccurs="0"/&gt;
          &lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
        &lt;xsd:attribute name="partNum" type="SKU" use="required"/&gt;
      &lt;/xsd:complexType&gt;
    &lt;/xsd:element&gt;
  &lt;/xsd:sequence&gt;
&lt;/xsd:complexType&gt;
</eg>
</note>
    <p>
       In the case of the <code>item</code> element, it has an
      anonymous complex type consisting of the elements <code>
      productName</code>, <code>quantity</code>, <code>
      USPrice</code>, <code>comment</code>, and <code>
      shipDate</code>, and an attribute called <code>
      partNum</code>. In the case of the <code>quantity</code>
      element, it has an anonymous simple type derived from
      <phrase diff="del"><code><loc href="#integer">integer</loc></code></phrase><phrase diff="add">
      <code><loc href="#positiveInteger">positiveInteger</loc></code></phrase> whose value
      ranges between 1 and 99.
    </p>
    </div2>
    <div2 id="typeContent"><head>Element Content</head>
    <p>
       The purchase order schema has many examples of elements
      containing other elements (e.g. <code>items</code>),
      elements having attributes and containing other elements
      (e.g. <code>shipTo</code>), and elements containing only a
      simple type of value (e.g. <code>USPrice</code>). However,
      we have not seen an element having attributes but
      containing only a simple type of value, nor have we seen an
      element that contains other elements mixed with character
      content, nor have we seen an element that has no content at
      all. In this section we'll examine these variations in the
      content models of elements.
    </p>
    <div3 id="complexTfromSimpleT"><head>Complex Types from Simple Types</head>
    <p>
       Let us first consider how to declare an element that has
      an attribute and contains a simple value. In an instance
      document, such an element might appear as:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;internationalPrice currency="EUR"&gt;423.46&lt;/internationalPrice&gt;
</eg>
</note>
    <p>
       The purchase order schema declares a <code>USPrice</code>
      element that is a starting point:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;xsd:element name="USPrice" type="decimal"/&gt;
</eg>
</note>
    <p id="ref37">Now, how do we add an attribute to
      this element? As we have said before, simple types cannot
      have attributes, and <code><loc href="#decimal">
      decimal</loc></code> is a simple type. Therefore, we must
      define a complex type to carry the attribute declaration.
      We also want the content to be simple type <code> <loc href="#decimal">decimal</loc></code>. So our original question
      becomes: How do we define a complex type that is based on
      the simple type <code><loc href="#decimal">
      decimal</loc></code>? The answer is to <emph>derive</emph> a new
      complex type from the simple type <code><loc href="#decimal">
      decimal</loc></code>:
    </p>
<note id="DerivingAComplexType" role="example"><p>Deriving a Complex Type from a Simple Type</p>
<eg xml:space="preserve">
&lt;xsd:element name="internationalPrice"&gt;
  &lt;xsd:complexType&gt;
    &lt;xsd:simpleContent&gt;
      &lt;xsd:extension base="xsd:decimal"&gt;
        &lt;xsd:attribute name="currency" type="xsd:string"/&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:simpleContent&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:element&gt;
</eg>
</note>
    <p>
       We use the <code><loc href="#element-complexType">
      complexType</loc></code> element to start the definition of a
      new (anonymous) type. To indicate that the content model of
      the new type contains only character data and no elements,
      we use a <code><loc href="#element-simpleContent">
      simpleContent</loc></code> element. Finally, we derive the
      new type by extending the simple <code><loc href="#decimal">
      decimal</loc></code> type. The extension consists of adding a
      <code>currency</code> attribute using a standard attribute
      declaration. (We cover type derivation in detail in <specref ref="IPO"/>.) The <code>
      internationalPrice</code> element declared in this way will
      appear in an instance as shown in the example at the
      beginning of this section.
    </p>
    </div3>
    <div3 id="mixedContent"><head>Mixed Content</head>
    <p id="ref51">The construction of the purchase order schema may be
      characterized as elements containing subelements, and the
      deepest subelements contain character data. XML Schema also
      provides for the construction of schemas where character
      data can appear alongside subelements, and character data
      is not confined to the deepest subelements.
    </p>
    <p>
       To illustrate, consider the following snippet from a
      customer letter that uses some of the same elements as the
      purchase order:
    </p>
<note id="SnippetOfCustomerLetter" role="example"><p>Snippet of Customer Letter</p>
<eg xml:space="preserve">
&lt;letterBody&gt;
&lt;salutation&gt;Dear Mr.&lt;name&gt;Robert Smith&lt;/name&gt;.&lt;/salutation&gt;
Your order of &lt;quantity&gt;1&lt;/quantity&gt; &lt;productName&gt;Baby
Monitor&lt;/productName&gt; shipped from our warehouse on
&lt;shipDate&gt;1999-05-21&lt;/shipDate&gt;. ....
&lt;/letterBody&gt;
</eg>
</note>
    <p>
       Notice the text appearing between elements and their child
      elements. Specifically, text appears between the elements
      <code>salutation</code>, <code>quantity</code>, <code>
      productName</code> and <code>shipDate</code> which are all
      children of <code>letterBody</code>, and text appears
      around the element <phrase diff="del">name</phrase><phrase diff="add"><code>name</code>
      </phrase> which is the child of a child of
      <code>letterBody</code>. The following snippet of a schema
      declares <code>letterBody</code>:
    </p>
<note id="SnippetOfCustomerLetterSchema" role="example"><p>Snippet of Schema for Customer Letter</p>
<eg xml:space="preserve">
&lt;xsd:element name="letterBody"&gt;
  &lt;xsd:complexType mixed="true"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="salutation"&gt;
        &lt;xsd:complexType mixed="true"&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element name="name" type="xsd:string"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;
      &lt;/xsd:element&gt;
      &lt;xsd:element name="quantity"    type="xsd:positiveInteger"/&gt;
      &lt;xsd:element name="productName" type="xsd:string"/&gt;
      &lt;xsd:element name="shipDate"    type="xsd:date" minOccurs="0"/&gt;
      &lt;!-- etc. --&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:element&gt;
</eg>
</note>
    <p>
       The elements appearing in the customer letter are
      declared, and their types are defined using the <code><loc href="#element-element">element</loc></code> and <code><loc href="#element-complexType">complexType</loc></code> element
      constructions we have seen before. To enable character data
      to appear between the child-elements of <code>
      letterBody</code>, the <code><loc href="#attribute-mixed">
      mixed</loc></code> attribute on the type definition is set to
      true.
    </p>
    <p>
       Note that the <code>mixed</code> model in XML Schema
      differs fundamentally from the <loc href="http://www.w3.org/TR/2000/REC-xml-20001006#sec-mixed-content">
      mixed model in XML 1.0</loc>. Under the XML Schema
      mixed model, the order and number of child elements
      appearing in an instance must agree with the order and
      number of child elements specified in the model. In
      contrast, under the XML 1.0 mixed model, the order and
      number of child elements appearing in an instance cannot be
      constrained. In summary, XML Schema provides full validation of
      mixed models in contrast to the partial schema validation
      provided by XML 1.0.
    </p>
    </div3>
    <div3 id="emptyContent"><head>Empty Content</head>
    <p>
       Now suppose that we want the <code>
      internationalPrice</code> element to convey both the unit
      of currency and the price as attribute values rather than
      as separate attribute and content values. For example:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;internationalPrice currency="EUR" value="423.46"/&gt;
</eg>
</note>
    <p id="ref13">Such an element has no content at
      all; its content model is empty. To define a type whose
      content is empty, we essentially define a type that allows
      only elements in its content, but we do not actually
      declare any elements and so the type's content model is
      empty:
    </p>
<note id="AnEmptyComplexType" role="example"><p>An Empty Complex Type</p>
<eg xml:space="preserve">
&lt;xsd:element name="internationalPrice"&gt;
  &lt;xsd:complexType&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="xsd:anyType"&gt;
        &lt;xsd:attribute name="currency" type="xsd:string"/&gt;
        &lt;xsd:attribute name="value"    type="xsd:decimal"/&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:element&gt;
</eg>
</note>
    <p>
       In this example, we define an (anonymous) type having
      <code>complexContent</code>, i.e. only elements. The <code>
      complexContent</code> element signals that we intend to
      restrict or extend the content model of a complex type, and the
      <code>restriction</code> of <code>anyType</code> declares
      two attributes but does not introduce any element content
      (see <specref ref="DerivByRestrict"/> for more
      details on restriction). The <code>
      internationalPrice</code> element declared in this way may
      legitimately appear in an instance as shown in the example
      above.
    </p>
    <p>
       The preceding syntax for an empty-content element is
      relatively verbose, and it is possible to declare the
      <code>internationalPrice</code> element more compactly:
    </p>
<note id="ShorthandForAnEmptyComplexType" role="example"><p>Shorthand for an Empty Complex Type</p>
<eg xml:space="preserve">
&lt;xsd:element name="internationalPrice"&gt;
  &lt;xsd:complexType&gt;
    &lt;xsd:attribute name="currency" type="xsd:string"/&gt;
    &lt;xsd:attribute name="value"    type="xsd:decimal"/&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:element&gt;
</eg>
</note>
    <p>
       This compact syntax works because a complex type defined
      without any <code>simpleContent</code> or <code>
      complexContent</code> is interpreted as shorthand for
      complex content that restricts <code>anyType</code>.
    </p>
    </div3>
    <div3 id="anyType"><head>anyType</head>
    <p>
       The <code>anyType</code> represents an abstraction called
      the <xspecref href="&part1;#Type_Derivation">
       ur-type</xspecref> which is the base type from which all
      simple and complex types are derived. An <code>
      anyType</code> type does not constrain its content in any
      way. It is possible to use <code>anyType</code> like other
      types, for example:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;xsd:element name="anything" type="xsd:anyType"/&gt;
</eg>
</note>
    <p>
       The content of the element declared in this way is
      unconstrained, so the element value may be 423.46, but it
      may be any other sequence of characters as well, or indeed
      a mixture of characters and elements. In fact, <code>
      anyType</code> is the default type when none is specified,
      so the above could also be written as follows:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;xsd:element name="anything"/&gt;
</eg>
</note>
    <p>
      If unconstrained element content is needed, for example in
      the case of elements containing prose which requires embedded
      markup to support internationalization, then the default
      declaration or a slightly restricted form of it may be suitable.
      The <code>text</code> type described in <specref ref="any"/>
      is an example of such a type that is suitable for such
      purposes.
    </p>
    </div3></div2>
    <div2 id="CommVers"><head>Annotations</head>
    <p id="ref14">XML Schema provides three elements
      for annotating schemas for the benefit of both human
      readers and applications. In the purchase order schema, we
      put a basic schema description and copyright information
      inside the <code><loc href="#element-documentation">
      documentation</loc></code> element, which is the recommended
      location for human readable material. We recommend you use
      the <code>xml:lang</code> attribute with any
      <code><loc href="#element-documentation">documentation</loc></code>
      elements to indicate the language of the information. Alternatively,
      you may indicate the language of all information in a schema by placing
      an <code>xml:lang</code> attribute on the <code>schema</code> element.
    </p>
    <p id="ref15">The <phrase diff="add"><code><loc href="#element-appinfo">appinfo</loc></code></phrase><phrase diff="del"><code><loc href="#element-appinfo">appInfo</loc></code></phrase> element, which we did not use in the
      purchase order schema, can be used to provide information
      for tools, stylesheets and other applications. An
      interesting example using <phrase diff="add"><code><loc href="#element-appinfo">appinfo</loc></code></phrase><phrase diff="del"><code><loc href="#element-appinfo">appInfo</loc></code></phrase> is a
      <xspecref href="&part2;#schema">schema</xspecref>
      that describes
      the simple types in XML Schema Part 2: Datatypes.
      Information describing this schema, e.g. which facets are
      applicable to particular simple types, is represented
      inside <phrase diff="add"><code><loc href="#element-appinfo">appinfo</loc></code></phrase><phrase diff="del"><code><loc href="#element-appinfo">appInfo</loc></code></phrase>
      elements, and this information was used by an application to automatically
      generate text for the XML Schema Part 2 document.
    </p>
    <p id="ref16">Both <code><loc href="#element-documentation">documentation</loc></code> and
      <phrase diff="add"><code><loc href="#element-appinfo">appinfo</loc></code></phrase><phrase diff="del"><code><loc href="#element-appinfo">appInfo</loc></code></phrase> appear
      as subelements of <code><loc href="#element-annotation">
      annotation</loc></code>, which may itself appear at the
      beginning of most schema constructions. To illustrate, the
      following example shows <code><loc href="#element-annotation">annotation</loc></code> elements
      appearing at the beginning of an element declaration and a
      complex type definition:
    </p>
<note id="AnnotationsInElementDeclaration" role="example"><p>Annotations in Element Declaration &amp; Complex Type Definition</p>
<eg xml:space="preserve">
&lt;xsd:element name="internationalPrice"&gt;
  &lt;xsd:annotation&gt;
    &lt;xsd:documentation xml:lang="en"&gt;
         element declared with anonymous type
    &lt;/xsd:documentation&gt;
  &lt;/xsd:annotation&gt;
  &lt;xsd:complexType&gt;
    &lt;xsd:annotation&gt;
      &lt;xsd:documentation xml:lang="en"&gt;
           empty anonymous type with 2 attributes
      &lt;/xsd:documentation&gt;
    &lt;/xsd:annotation&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="xsd:anyType"&gt;
        &lt;xsd:attribute name="currency" type="xsd:string"/&gt;
        &lt;xsd:attribute name="value"    type="xsd:decimal"/&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:element&gt;
</eg>
</note>
    <p>
       The <code><loc href="#element-annotation">
      annotation</loc></code> element may also appear at the
      beginning of other schema constructions such as those
      indicated by the elements <code><loc href="#element-schema">
      schema</loc></code>, <code><loc href="#element-simpleType">
      simpleType</loc></code>, and <code><loc href="#element-attribute">attribute</loc></code>.
    </p>
    </div2>
    <div2 id="groups"><head>Building Content Models</head>
    <p>
       The definitions of complex types in the purchase order
      schema all declare sequences of elements that must appear
      in the instance document. The occurrence of individual
      elements declared in the so-called content models of these
      types may be optional, as indicated by a 0 value for the
      attribute <code><loc href="#attribute-minOccurs">
      minOccurs</loc></code> (e.g. in <code> comment</code>), or be
      otherwise constrained depending upon the values of <code><loc href="#attribute-minOccurs">minOccurs</loc></code> and <code>
      <loc href="#attribute-maxOccurs">maxOccurs</loc></code>. XML
      Schema also provides constraints that apply to groups of
      elements appearing in a content model. These constraints
      mirror those available in XML 1.0 plus some additional
      constraints. Note that the constraints do not apply to
      attributes.
    </p>
    <p>
       XML Schema enables groups of elements to be defined and
      named, so that the elements can be used to build up the
      content models of complex types (thus mimicking common
      usage of parameter entities in XML 1.0). Un-named groups of
      elements can also be defined, and along with elements in
      named groups, they can be constrained to appear in the same
      order (sequence) as they are declared. Alternatively, they
      can be constrained so that only one of the elements may
      appear in an instance.
    </p>
    <p id="ref17">To illustrate, we introduce two groups
      into the <code>PurchaseOrderType</code> definition from the
      purchase order schema so that purchase orders may contain
      either separate shipping and billing addresses, or a single
      address for those cases in which the shippee and billee are
      co-located:
    </p>
<note id="NestedChoiceAndSequenceGroups" role="example"><p>Nested Choice and Sequence Groups</p>
<eg xml:space="preserve">
&lt;xsd:complexType name="PurchaseOrderType"&gt;
  &lt;xsd:sequence&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:group   ref="shipAndBill"/&gt;
      &lt;xsd:element name="singleUSAddress" type="USAddress"/&gt;
    &lt;/xsd:choice&gt;
    &lt;xsd:element ref="comment" minOccurs="0"/&gt;
    &lt;xsd:element name="items"  type="Items"/&gt;
  &lt;/xsd:sequence&gt;
  &lt;xsd:attribute name="orderDate" type="xsd:date"/&gt;
&lt;/xsd:complexType&gt;

&lt;xsd:group id="shipAndBill"&gt;
  &lt;xsd:sequence&gt;
    &lt;xsd:element name="shipTo" type="USAddress"/&gt;
    &lt;xsd:element name="billTo" type="USAddress"/&gt;
  &lt;/xsd:sequence&gt;
&lt;/xsd:group&gt;
</eg>
</note>
    <p>
       The <code><loc href="#element-choice">choice</loc></code>
      group element allows only one of its children to appear in
      an instance. One child is an inner <code><loc href="#element-group">group</loc></code> element that references
      the named group <code>shipAndBill</code> consisting of the
      element sequence <code>shipTo</code>, <code>billTo</code>,
      and the second child is a <code>singleUSAddress</code>.
      Hence, in an instance document, the <code>
      purchaseOrder</code> element must contain either a <code>
      shipTo</code> element followed by a <code> billTo</code>
      element or a <code>singleUSAddress</code> element. The
      <code><loc href="#element-choice">choice</loc></code> group is
      followed by the <code>comment</code> and <code>items</code>
      element declarations, and both the <code><loc href="#element-choice">choice</loc></code> group and the element
      declarations are children of a <code><loc href="#element-sequence">sequence</loc></code> group. The effect
      of these various groups is that the address element(s) must
      be followed by <code>comment</code> and <code>items</code>
      elements in that order.
    </p>
    <p id="ref18">There exists a third option for
      constraining elements in a group: All the elements in the
      group may appear once or not at all, and they may appear in
      any order. The <code><loc href="#element-all">all</loc></code>
      group (which provides a simplified version of the SGML
      &amp;-Connector) is limited to the top-level of any content
      model. Moreover, the group's children must all be
      individual elements (no groups), and no element in the
      content model may appear more than once, i.e. the
      permissible values of <code><loc href="#attribute-minOccurs">
      minOccurs</loc></code> and <code><loc href="#attribute-maxOccurs">maxOccurs</loc></code> are 0 and 1.
      For example, to allow the child elements of <code>
      purchaseOrder</code> to appear in any order, we could
      redefine <code> PurchaseOrderType</code> as:
    </p>
<note id="AnAllGroup" role="example"><p>An 'All' Group</p>
<eg xml:space="preserve">
&lt;xsd:complexType name="PurchaseOrderType"&gt;
  &lt;xsd:all&gt;
    &lt;xsd:element name="shipTo" type="USAddress"/&gt;
    &lt;xsd:element name="billTo" type="USAddress"/&gt;
    &lt;xsd:element ref="comment" minOccurs="0"/&gt;
    &lt;xsd:element name="items"  type="Items"/&gt;
  &lt;/xsd:all&gt;
  &lt;xsd:attribute name="orderDate" type="xsd:date"/&gt;
&lt;/xsd:complexType&gt;
</eg>
</note>
    <p>
       By this definition, a <code>comment</code> element may
      optionally appear within <code>purchaseOrder</code>, and it
      may appear before or after any <code>shipTo</code>, <code>
      billTo</code> and <code>items</code> elements, but it can
      appear only once. Moreover, the stipulations of an <code><loc href="#element-all">all</loc></code> group do not allow us to
      declare an element such as <code>comment</code> outside the
      group as a means of enabling it to appear more than once.
      XML Schema stipulates that an <code><loc href="#element-all">
      all</loc></code> group must appear as the sole child at the
      top of a content model. In other words, the following is
      illegal:
    </p>
<note id="IllegalExampleWithAllGroup" role="example"><p>Illegal Example with an 'All' Group</p>
<eg xml:space="preserve">
&lt;xsd:complexType name="PurchaseOrderType"&gt;
  &lt;xsd:sequence&gt;
    &lt;xsd:all&gt;
      &lt;xsd:element name="shipTo" type="USAddress"/&gt;
      &lt;xsd:element name="billTo" type="USAddress"/&gt;
      &lt;xsd:element name="items"  type="Items"/&gt;
    &lt;/xsd:all&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="comment" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:sequence&gt;
  &lt;xsd:attribute name="orderDate" type="xsd:date"/&gt;
&lt;/xsd:complexType&gt;
</eg>
</note>
    <p>
       Finally, named and un-named groups that appear in content
      models (represented by <code><loc href="#element-group">
      group</loc></code> and <code><loc href="#element-choice">
      choice</loc></code>, <code><loc href="#element-sequence">
      sequence</loc></code>, <code><loc href="#element-all">
      all</loc></code> respectively) may carry <code><loc href="#attribute-minOccurs">minOccurs</loc></code> and <code><loc href="#attribute-maxOccurs">maxOccurs</loc></code>
      attributes. By combining and nesting the various groups
      provided by XML Schema, and by setting the values of <code>
      <loc href="#attribute-minOccurs">minOccurs</loc></code> and
      <code><loc href="#attribute-maxOccurs">maxOccurs</loc></code>,
      it is possible to represent any content model expressible
      with an XML 1.0 DTD. Furthermore, the <code><loc href="#element-all">all</loc></code> group provides additional
      expressive power.
    </p>
    </div2>
    <div2 id="AttrGroups"><head>Attribute Groups</head>
    <p>
       Suppose we want to provide more information about each
      item in a purchase order, for example, each item's weight
      and preferred shipping method. We can accomplish this by
      adding <code>weightKg</code> and <code>shipBy</code>
      attribute declarations to the <code>item</code> element's
      (anonymous) type definition:
    </p>
<note id="AddingAttributesToInline" role="example"><p>Adding Attributes to the Inline Type Definition</p>
<eg xml:space="preserve">
&lt;xsd:element name="<phrase diff="del">Item</phrase><phrase diff="add">item</phrase>" minOccurs="0" maxOccurs="unbounded"&gt;
  &lt;xsd:complexType&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element   name="productName" type="xsd:string"/&gt;
      &lt;xsd:element   name="quantity"&gt;
        &lt;xsd:simpleType&gt;
          &lt;xsd:restriction base="xsd:positiveInteger"&gt;
            &lt;xsd:maxExclusive value="100"/&gt;
          &lt;/xsd:restriction&gt;
        &lt;/xsd:simpleType&gt;
      &lt;/xsd:element&gt;
      &lt;xsd:element name="USPrice"  type="xsd:decimal"/&gt;
      &lt;xsd:element ref="comment"   minOccurs="0"/&gt;
      &lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="partNum"  type="SKU" use="required"/&gt;
    &lt;!-- add weightKg and shipBy attributes --&gt;
    &lt;xsd:attribute name="weightKg" type="xsd:decimal"/&gt;
    &lt;xsd:attribute name="shipBy"&gt;
      &lt;xsd:simpleType&gt;
        &lt;xsd:restriction base="xsd:string"&gt;
          &lt;xsd:enumeration value="air"/&gt;
          &lt;xsd:enumeration value="land"/&gt;
          &lt;xsd:enumeration value="any"/&gt;
        &lt;/xsd:restriction&gt;
      &lt;/xsd:simpleType&gt;
    &lt;/xsd:attribute&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:element&gt;
</eg>
</note>
    <p id="ref19">Alternatively, we can create a named
      attribute group containing all the desired attributes of an
      <code>item</code> element, and reference this group by name
      in the <code>item</code> element declaration:
    </p>
<note id="AddingAttributesUsingGroup" role="example"><p>Adding Attributes Using an Attribute Group</p>
<eg xml:space="preserve">
&lt;xsd:element name="item" minOccurs="0" maxOccurs="unbounded"&gt;
  &lt;xsd:complexType&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="productName" type="xsd:string"/&gt;
      &lt;xsd:element name="quantity"&gt;
        &lt;xsd:simpleType&gt;
          &lt;xsd:restriction base="xsd:positiveInteger"&gt;
            &lt;xsd:maxExclusive value="100"/&gt;
          &lt;/xsd:restriction&gt;
        &lt;/xsd:simpleType&gt;
      &lt;/xsd:element&gt;
      &lt;xsd:element name="USPrice"  type="xsd:decimal"/&gt;
      &lt;xsd:element ref="comment"   minOccurs="0"/&gt;
      &lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;

    &lt;!-- attributeGroup replaces individual declarations --&gt;
    &lt;xsd:attributeGroup ref="ItemDelivery"/&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:element&gt;

&lt;xsd:attributeGroup id="ItemDelivery"&gt;
  &lt;xsd:attribute name="partNum"  type="SKU" use="required"/&gt;
  &lt;xsd:attribute name="weightKg" type="xsd:decimal"/&gt;
  &lt;xsd:attribute name="shipBy"&gt;
    &lt;xsd:simpleType&gt;
      &lt;xsd:restriction base="xsd:string"&gt;
        &lt;xsd:enumeration value="air"/&gt;
        &lt;xsd:enumeration value="land"/&gt;
        &lt;xsd:enumeration value="any"/&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
  &lt;/xsd:attribute&gt;
&lt;/xsd:attributeGroup&gt;
</eg>
</note>
    <p>
       Using an attribute group in this way can improve the
      readability of schemas, and facilitates updating schemas
      because an attribute group can be defined and edited in one
      place and referenced in multiple definitions and
      declarations. These characteristics of attribute groups
      make them similar to parameter entities in XML 1.0. Note
      that an attribute group may contain other attribute groups.
      Note also that both attribute declarations and attribute
      group references must appear at the end of complex type
      definitions.
    </p>
    </div2>
    <div2 id="Nils"><head>Nil Values</head>
    <p>
       One of the purchase order items listed in <code> <loc href="#po.xml">po.xml</loc></code>, the <code>Lawnmower</code>,
      does not have a <code>shipDate</code> element. Within the
      context of our scenario, the schema author may have
      intended such absences to indicate <code>item</code>s not
      yet shipped. But in general, the absence of an element does
      not have any particular meaning: It may indicate that the
      information is unknown, or not applicable, or the element
      may be absent for some other reason. Sometimes it is
      desirable to represent an unshipped <code>item</code>,
      unknown information, or inapplicable information <emph>
      explicitly</emph> with an element, rather than by an absent
      element. For example, it may be desirable to represent a
      "null" value being sent to or from a relational database
      with an element that is present. Such cases can be
      represented using XML Schema's nil mechanism which enables
      an element to appear with or without a non-nil value.
    </p>
    <p id="ref20">XML Schema's nil mechanism involves
      an "out of band" nil signal. In other words, there is no
      actual nil value that appears as element content, instead
      there is an attribute to indicate that the element content
      is nil. To illustrate, we modify the <code>
      shipDate</code> element declaration so that nils can be
      signalled:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;xsd:element name="shipDate" type="xsd:date" nillable="true"/&gt;
</eg>
</note>
    <p id="ref21">And to explicitly represent that
      <code>shipDate</code> has a nil value in the instance
      document, we set the <code><loc href="#attribute-xsinil">nil</loc></code>
      attribute (from the XML Schema
      namespace for instances) to true:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;shipDate xsi:nil="true"&gt;&lt;/shipDate&gt;
</eg>
</note>
    <p>
       The <code><loc href="#attribute-xsinil">nil</loc></code>
      attribute is defined as part of the XML Schema namespace
      for instances,
      <code>http://www.w3.org/2001/XMLSchema-instance</code>,
      and so it must appear in the instance document with a
      prefix (such as <code>xsi:</code>) associated with that namespace.
      (As with the <code>xsd:</code> prefix, the <code>
      xsi:</code> prefix is used by convention only.) Note that
      the nil mechanism applies only to element values, and not
      to attribute values. An element with <code> <loc href="#attribute-xsinil">xsi:nil</loc>="true"</code> may not
      have any element content but it may still carry attributes.
    </p>
    </div2>
    </div1>
    <div1 id="NS"><head>Advanced Concepts I: Namespaces, Schemas &amp; Qualification</head>
    <p id="ref38">A schema can be viewed as a
      collection (vocabulary) of type definitions and element
      declarations whose names belong to a particular namespace
      called a target namespace. Target namespaces enable us
      to distinguish between definitions and declarations from
      different vocabularies. For example, target namespaces
      would enable us to distinguish between the declaration for
      <code><loc href="#element-element">element</loc></code> in the
      XML Schema language vocabulary, and a declaration for
      <code>element</code> in a hypothetical chemistry language
      vocabulary. The former is part of the <code>
      http://www.w3.org/2001/XMLSchema</code> target
      namespace, and the latter is part of another target
      namespace.
    </p>
    <p id="ref22">When we want to check that an
      instance document conforms to one or more schemas (through
      a process called schema validation), we need to identify
      which element and attribute declarations and type
      definitions in the schemas should be used to check which
      elements and attributes in the instance document. The
      target namespace plays an important role in the
      identification process. We examine the role of the target
      namespace in the next section.
    </p>
    <p>
       The schema author also has several options that affect how
      the identities of elements and attributes are represented
      in instance documents. More specifically, the author can
      decide whether or not the appearance of locally declared
      elements and attributes in an instance must be qualified by
      a namespace, using either an explicit prefix or implicitly
      by default. The schema author's choice regarding
      qualification of local elements and attributes has a number
      of implications regarding the structures of schemas and
      instance documents, and we examine some of these
      implications in the following sections.
    </p>
    <div2 id="UnqualLocals"><head>Target Namespaces &amp; Unqualified Locals</head>
    <p id="ref56">
       In a new version of the purchase order schema, <code><loc href="#po1.xsd">po1.xsd</loc></code>, we explicitly declare
      a target namespace, and specify that both locally defined
      elements and locally defined attributes must be
      unqualified. The target namespace in <code><loc href="#po1.xsd">po1.xsd</loc></code> is <code>
      http://www.example.com/PO1</code>, as indicated by the
      value of the <code><loc href="#attribute-targetNamespace">
      targetNamespace</loc></code> attribute.
    </p>
    <p id="ref50">Qualification of local elements and attributes can be
      globally specified by a pair of attributes, <code><loc href="#attribute-elementFormDefault">
      elementFormDefault</loc></code> and <code><loc href="#attribute-attributeFormDefault">
      attributeFormDefault</loc></code>, on the <code><loc href="#element-schema">schema</loc></code> element, or can be
      specified separately for each local declaration using the
      <code><loc href="#attribute-form">form</loc></code> attribute.
      All such attributes' values may each be set to <code>
      unqualified</code> or <code>qualified</code>, to indicate
      whether or not locally declared elements and attributes
      must be unqualified.
    </p>
    <p>
       In <code><loc href="#po1.xsd">po1.xsd</loc></code> we globally
      specify the qualification of elements and attributes by
      setting the values of both <code><loc href="#attribute-elementFormDefault">
      elementFormDefault</loc></code> and <code><loc href="#attribute-attributeFormDefault">
      attributeFormDefault</loc></code> to <code>
      unqualified</code>. Strictly speaking, these settings are
      unnecessary because the values are the defaults for the two
      attributes; we make them here to highlight the contrast between
      this case and other cases we describe later.
    </p>
<note id="po1.xsd" role="example"><p>Purchase Order Schema with Target Namespace, po1.xsd</p>
<eg xml:space="preserve">
&lt;schema xmlns="http://www.w3.org/2001/XMLSchema"
        xmlns:po="http://www.example.com/PO1"
        targetNamespace="http://www.example.com/PO1"
        elementFormDefault="unqualified"
        attributeFormDefault="unqualified"&gt;

  &lt;element name="purchaseOrder" type="po:PurchaseOrderType"/&gt;
  &lt;element name="comment"       type="string"/&gt;

  &lt;complexType name="PurchaseOrderType"&gt;
    &lt;sequence&gt;
      &lt;element name="shipTo"    type="po:USAddress"/&gt;
      &lt;element name="billTo"    type="po:USAddress"/&gt;
      &lt;element ref="po:comment" minOccurs="0"/&gt;
      &lt;!-- etc. --&gt;
    &lt;/sequence&gt;
    &lt;!-- etc. --&gt;
  &lt;/complexType&gt;

  &lt;complexType name="USAddress"&gt;
    &lt;sequence&gt;
      &lt;element name="name"   type="string"/&gt;
      &lt;element name="street" type="string"/&gt;
      &lt;!-- etc. --&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;

  &lt;!-- etc. --&gt;

&lt;/schema&gt;
</eg>
</note>
    <p>
       To see how the target namespace of this schema is
      populated, we examine in turn each of the type
      definitions and element declarations. Starting from the end
      of the schema, we first define a type called <code>
      USAddress</code> that consists of the elements <code>
      name</code>, <code>street</code>, etc. One consequence of
      this type definition is that the <code>USAddress</code>
      type is included in the schema's target namespace. We next
      define a type called <code>PurchaseOrderType</code> that
      consists of the elements <code>shipTo</code>, <code>
      billTo</code>, <code>comment</code>, etc. <code>
      PurchaseOrderType</code> is also included in the schema's
      target namespace. Notice that the type references in the
      three element declarations are prefixed, i.e. <code>
      po:USAddress</code>, <code>po:USAddress</code> and <code>
      po:comment</code>, and the prefix is associated with the
      namespace <code>http://www.example.com/PO1</code>. This is
      the same namespace as the schema's target namespace, and so
      a processor of this schema will know to look within this
      schema for the definition of the type <code>
      USAddress</code> and the declaration of the element <code>
      comment</code>. It is also possible to refer to types in
      another schema with a different target namespace, hence
      enabling re-use of definitions and declarations between
      schemas.
    </p>
    <p>
       At the beginning of the schema <code><loc href="#po1.xsd">
      po1.xsd</loc></code>, we declare the elements <code>
      purchaseOrder</code> and <code> comment</code>. They are
      included in the schema's target namespace. The <code>
      purchaseOrder</code> element's type is prefixed, for the
      same reason that <code>USAddress</code> is prefixed. In
      contrast, the <code>comment</code> element's type, <code><loc href="#string">string</loc></code>, is not prefixed. The
      <code> <loc href="#po1.xsd">po1.xsd</loc></code> schema
      contains a default namespace declaration, and so unprefixed
      types such as <code><loc href="#string">string</loc></code>
      and unprefixed elements such as <code> <loc href="#element-element">element</loc></code> and <code><loc href="#element-complexType">complexType</loc></code> are
      associated with the default namespace <code>
      http://www.w3.org/2001/XMLSchema</code>. In fact, this
      is the target namespace of XML Schema itself, and so a
      processor of <code><loc href="#po1.xsd">po1.xsd</loc></code>
      will know to look within the schema of XML Schema
      -- otherwise known as the "schema for schemas" -- for the
      definition of the type <code> <loc href="#string">
      string</loc></code> and the declaration of the element called
      <code><loc href="#element-element">element</loc></code>.
    </p>
    <p>
       Let us now examine how the target namespace of the schema
      affects a conforming instance document:
    </p>
<note id="po1.xml" role="example"><p>A Purchase Order with Unqualified Locals, po1.xml</p>
<eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;apo:purchaseOrder xmlns:apo="http://www.example.com/PO1"
                   orderDate="1999-10-20"&gt;
  &lt;shipTo country="US"&gt;
    &lt;name&gt;Alice Smith&lt;/name&gt;
    &lt;street&gt;123 Maple Street&lt;/street&gt;
    &lt;!-- etc. --&gt;
  &lt;/shipTo&gt;
  &lt;billTo country="US"&gt;
    &lt;name&gt;Robert Smith&lt;/name&gt;
    &lt;street&gt;8 Oak Avenue&lt;/street&gt;
    &lt;!-- etc. --&gt;
  &lt;/billTo&gt;
  &lt;apo:comment&gt;Hurry, my lawn is going wild&lt;!/apo:comment&gt;
  &lt;!-- etc. --&gt;
&lt;/apo:purchaseOrder&gt;
</eg>
</note>
    <p>
       The instance document declares one namespace, <code>
      http://www.example.com/PO1</code>, and associates it with
      the prefix <code>apo:</code>. This prefix is used to
      qualify two elements in the document, namely <code>
      purchaseOrder</code> and <code>comment</code>. The
      namespace is the same as the target namespace of the schema
      in <code><loc href="#po1.xsd">po1.xsd</loc></code>, and so a
      processor of the instance document will know to look in
      that schema for the declarations of <code>
      purchaseOrder</code> and <code>comment</code>. In fact,
      target namespaces are so named because of the sense in
      which there exists a target namespace for the elements
      <code>purchaseOrder</code> and <code>comment</code>. Target
      namespaces in the schema therefore control the validation
      of corresponding namespaces in the instance.
    </p>
    <p>
       The prefix <code>apo:</code> is applied to the global
      elements <code>purchaseOrder</code> and <code>
      comment</code> elements. Furthermore, <code><loc href="#attribute-elementFormDefault">
      elementFormDefault</loc></code> and <code><loc href="#attribute-attributeFormDefault">
      attributeFormDefault</loc></code> require that the prefix is
      <emph>not</emph> applied to any of the locally declared
      elements such as <code>shipTo</code>, <code>billTo</code>,
      <code> name</code> and <code>street</code>, and it is <emph>
      not</emph> applied to any of the attributes (which were all
      declared locally). The <code>purchaseOrder</code> and
      <code> comment</code> are global elements because they are
      declared in the context of the schema as a whole rather
      than within the context of a particular type. For example,
      the declaration of <code>purchaseOrder</code> appears as a
      child of the <code><loc href="#element-schema">
      schema</loc></code> element in <code> <loc href="#po1.xsd">
      po1.xsd</loc></code>, whereas the declaration of <code>
      shipTo</code> appears as a child of the <code> <loc href="#element-complexType">complexType</loc></code> element that
      defines <code>PurchaseOrderType</code>.
    </p>
    <p>
       When local elements and attributes are not required to be
      qualified, an instance author may require more or less
      knowledge about the details of the schema to create schema
      valid instance documents. More specifically, if the author
      can be sure that only the root element (such as <code>
      purchaseOrder</code>) is global, then it is a simple matter
      to qualify only the root element. Alternatively, the author
      may know that all the elements are declared globally, and
      so all the elements in the instance document can be
      prefixed, perhaps taking advantage of a default namespace
      declaration. (We examine this approach in <specref ref="GlobalvsLocal"/>.) On the other hand, if
      there is no uniform pattern of global and local
      declarations, the author will need detailed knowledge of
      the schema to correctly prefix global elements and
      attributes.
    </p>
    </div2>
    <div2 id="QualLocals"><head>Qualified Locals</head>
    <p>
       Elements and attributes can be independently required to
      be qualified, although we start by describing the
      qualification of local elements. To specify that all
      locally declared elements in a schema must be qualified, we
      set the value of <code><loc href="#attribute-elementFormDefault">
      elementFormDefault</loc></code> to <code>qualified</code>:
    </p>
<note id="ModificationsToPO1" role="example"><p>Modifications to <loc href="#po1.xsd">po1.xsd</loc> for
          Qualified Locals</p>
<eg xml:space="preserve">
&lt;schema xmlns="http://www.w3.org/2001/XMLSchema"
        xmlns:po="http://www.example.com/PO1"
        targetNamespace="http://www.example.com/PO1"
        elementFormDefault="qualified"
        attributeFormDefault="unqualified"&gt;

  &lt;element name="purchaseOrder" type="po:PurchaseOrderType"/&gt;
  &lt;element name="comment"       type="string"/&gt;

  &lt;complexType name="PurchaseOrderType"&gt;
    &lt;!-- etc. --&gt;
  &lt;/complexType&gt;

  &lt;!-- etc. --&gt;

&lt;/schema&gt;
</eg>
</note>
    <p>
       And in this conforming instance document, we qualify all
      the elements explicitly:
    </p>
<note id="POWithExplicitlyQualifiedLocals" role="example"><p>A Purchase Order with Explicitly Qualified Locals</p>
<eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;apo:purchaseOrder xmlns:apo="http://www.example.com/PO1"
                   orderDate="1999-10-20"&gt;
  &lt;apo:shipTo country="US"&gt;
    &lt;apo:name&gt;Alice Smith&lt;/apo:name&gt;
    &lt;apo:street&gt;123 Maple Street&lt;/apo:street&gt;
    &lt;!-- etc. --&gt;
  &lt;/apo:shipTo&gt;
  &lt;apo:billTo country="US"&gt;
    &lt;apo:name&gt;Robert Smith&lt;/apo:name&gt;
    &lt;apo:street&gt;8 Oak Avenue&lt;/apo:street&gt;
    &lt;!-- etc. --&gt;
  &lt;/apo:billTo&gt;
  &lt;apo:comment&gt;Hurry, my lawn is going wild&lt;!/apo:comment&gt;
  &lt;!-- etc. --&gt;
&lt;/apo:purchaseOrder&gt;
</eg>
</note>
    <p>
       Alternatively, we can replace the explicit qualification
      of every element with implicit qualification provided by a
      default namespace, as shown here in <code><loc href="#po2.xml">
      po2.xml</loc></code>:
    </p>
<note id="po2.xml" role="example"><p>A Purchase Order with Default Qualified Locals, po2.xml</p>
<eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;purchaseOrder xmlns="http://www.example.com/PO1"
               orderDate="1999-10-20"&gt;
  &lt;shipTo country="US"&gt;
    &lt;name&gt;Alice Smith&lt;/name&gt;
    &lt;street&gt;123 Maple Street&lt;/street&gt;
    &lt;!-- etc. --&gt;
  &lt;/shipTo&gt;
  &lt;billTo country="US"&gt;
    &lt;name&gt;Robert Smith&lt;/name&gt;
    &lt;street&gt;8 Oak Avenue&lt;/street&gt;
    &lt;!-- etc. --&gt;
  &lt;/billTo&gt;
  &lt;comment&gt;Hurry, my lawn is going wild&lt;!/comment&gt;
  &lt;!-- etc. --&gt;
&lt;/purchaseOrder&gt;
</eg>
</note>
    <p>
       In <code><loc href="#po2.xml">po2.xml</loc></code>, all the elements in the
      instance belong to the same namespace, and the namespace
      statement declares a default namespace that applies to all
      the elements in the instance. Hence, it is unnecessary to
      explicitly prefix any of the elements. As another
      illustration of using qualified elements, the schemas in <specref ref="quartelyReport"/> all require qualified
      elements.
    </p>
    <p>
       Qualification of attributes is very similar to the
      qualification of elements. Attributes that must be
      qualified, either because they are declared globally or
      because the <code><loc href="#attribute-attributeFormDefault">
      attributeFormDefault</loc></code> attribute is set to <code>
      qualified</code>, appear prefixed in instance documents.
      One example of a qualified attribute is the <code><loc href="#attribute-xsinil">xsi:nil</loc></code> attribute that
      was introduced in <specref ref="Nils"/>. In
      fact, attributes that are required to be qualified must be
      explicitly prefixed because the <loc href="http://www.w3.org/TR/1999/REC-xml-names-19990114/">Namespaces in XML</loc>
      specification does not provide a mechanism for defaulting
      the namespaces of attributes. Attributes that are not
      required to be qualified appear in instance documents
      without prefixes, which is the typical case.
    </p>
    <p id="ref39">The qualification mechanism we have
      described so far has controlled all local element and
      attribute declarations within a particular target
      namespace. It is also possible to control qualification on
      a declaration by declaration basis using the <code><loc href="#attribute-form">form</loc></code> attribute. For example,
      to require that the locally declared attribute <code>
      publicKey</code> is qualified in instances, we declare it
      in the following way:
    </p>
<note id="RequiringQualification" role="example"><p>Requiring Qualification of Single Attribute</p>
<eg xml:space="preserve">
&lt;schema xmlns="http://www.w3.org/2001/XMLSchema"
        xmlns:po="http://www.example.com/PO1"
        targetNamespace="http://www.example.com/PO1"
        elementFormDefault="qualified"
        attributeFormDefault="unqualified"&gt;
  &lt;!-- etc. --&gt;
  &lt;element name="secure"&gt;
    &lt;complexType&gt;
      &lt;sequence&gt;
        &lt;!-- element declarations --&gt;
      &lt;/sequence&gt;
      &lt;attribute name="publicKey" type="base64Binary" form="qualified"/&gt;
    &lt;/complexType&gt;
  &lt;/element&gt;
&lt;/schema&gt;
</eg>
</note>
    <p>
       Notice that the value of the <code><loc href="#attribute-form">form</loc></code> attribute overrides the
      value of the <code><loc href="#attribute-attributeFormDefault">
      attributeFormDefault</loc></code> attribute for the <code>
      publicKey</code> attribute only. Also, the <code><loc href="#attribute-form">form</loc></code> attribute can be applied
      to an element declaration in the same manner. An instance
      document that conforms to the schema is:
    </p>
<note id="InstanceWithQualifiedAttribute" role="example"><p>Instance with a Qualified Attribute</p>
<eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;purchaseOrder xmlns="http://www.example.com/PO1"
               xmlns:po="http://www.example.com/PO1"
               orderDate="1999-10-20"&gt;
  &lt;!-- etc. --&gt;
  &lt;secure po:publicKey="GpM7"&gt;
    &lt;!-- etc. --&gt;
  &lt;/secure&gt;
&lt;/purchaseOrder&gt;
</eg>
</note>
    </div2>
    <div2 id="GlobalvsLocal"><head>Global vs. Local Declarations</head>
    <p>
       Another authoring style, applicable when all element names are
      unique within a namespace, is to create schemas in which
      all elements are global. This is similar in effect to the
      use of &lt;!ELEMENT&gt; in a DTD. In the example below, we
      have modified the original <code><loc href="#po1.xsd">po1.xsd</loc></code>
      such that all the elements are declared globally. Notice
      that we have omitted the <code><loc href="#attribute-elementFormDefault">
      elementFormDefault</loc></code> and <code><loc href="#attribute-attributeFormDefault">
      attributeFormDefault</loc></code> attributes in this example
      to emphasize that their values are irrelevant when there
      are only global element and attribute declarations.
    </p>
<note id="ModifiedVersionOfPO1" role="example"><p>Modified version of <loc href="#po1.xsd">po1.xsd</loc>
          using only global element declarations</p>
<eg xml:space="preserve">
&lt;schema xmlns="http://www.w3.org/2001/XMLSchema"
        xmlns:po="http://www.example.com/PO1"
        targetNamespace="http://www.example.com/PO1"&gt;

  &lt;element name="purchaseOrder" type="po:PurchaseOrderType"/&gt;

  &lt;element name="shipTo"  type="po:USAddress"/&gt;
  &lt;element name="billTo"  type="po:USAddress"/&gt;
  &lt;element name="comment" type="string"/&gt;

  &lt;element name="name" type="string"/&gt;
  &lt;element name="street" type="string"/&gt;

  &lt;complexType name="PurchaseOrderType"&gt;
    &lt;sequence&gt;
      &lt;element ref="po:shipTo"/&gt;
      &lt;element ref="po:billTo"/&gt;
      &lt;element ref="po:comment" minOccurs="0"/&gt;
      &lt;!-- etc. --&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;

  &lt;complexType name="USAddress"&gt;
    &lt;sequence&gt;
      &lt;element ref="po:name"/&gt;
      &lt;element ref="po:street"/&gt;
      &lt;!-- etc. --&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;

  &lt;!-- etc. --&gt;

&lt;/schema&gt;
</eg>
</note>
    <p>
       This "global" version of <code><loc href="#po1.xsd">po1.xsd</loc></code>
      will validate the instance document <code><loc href="#po2.xml">
      po2.xml</loc></code> which, as we described previously, is also
      schema valid against the "qualified" version of <code><loc href="#po1.xsd">po1.xsd</loc></code>. In other words, both schema
      approaches can validate the same, namespace defaulted,
      document. Thus, in one respect the two schema approaches
      are similar, although in another important respect the two
      schema approaches are very different. Specifically, when
      all elements are declared globally, it is not possible to
      take advantage of local names. For example, you can only
      declare one global element called "title". However, you can
      locally declare one element called "title" that has a
      string type, and is a subelement of "book". Within the same
      schema (target namespace) you can declare a second element
      also called "title" that is an enumeration of the values
      "Mr Mrs Ms".
    </p>
    </div2>
    <div2 id="UndeclaredTNS"><head>Undeclared Target Namespaces</head>
    <p>
       In <specref ref="PO"/> we explained the basics of
      XML Schema using a schema that did not declare a target
      namespace and an instance document that did not declare a
      namespace. So the question naturally arises: What is the
      target namespace in these examples and how is it
      referenced?
    </p>
    <p>
       In the purchase order schema, <code><loc href="#po.xsd">
      po.xsd</loc></code>, we did not declare a target namespace
      for the schema, nor did we declare a prefix (like <code>
      po</code>: above) associated with the schema's target
      namespace with which we could refer to types and elements
      defined and declared within the schema. The consequence of
      not declaring a target namespace in a schema is that the
      definitions and declarations from that schema, such as
      <code>USAddress</code> and <code>purchaseOrder</code>, are
      referenced without namespace qualification. In other words
      there is no explicit namespace prefix applied to the
      references nor is there any implicit namespace applied to
      the reference by default. So for example, the <code>
      purchaseOrder</code> element is declared using the type
      reference <code>PurchaseOrderType</code>. In contrast, all
      the XML Schema elements and types used in <code><loc href="#po.xsd">po.xsd</loc></code> are explicitly qualified with
      the prefix <code>xsd:</code> that is associated with the
      XML Schema namespace.
    </p>
    <p>
     In cases where a schema is designed without a target namespace, it is
     strongly recommended that all XML Schema elements and types are <emph>explicitly</emph>
     qualified with a prefix such as <code>xsd:</code> that is associated
     with the XML Schema namespace (as in <code><loc href="#po.xsd">po.xsd</loc></code>). The rationale for this recommendation is
     that if XML Schema elements and types are associated with the XML Schema
      namespace by default, i.e. without prefixes, then references to XML
     Schema types may not be distinguishable from references to user-defined
     types.
    </p>
    <p>
       Element declarations from a schema with no target
      namespace validate unqualified elements in the instance
      document. That is, they validate elements for which no
      namespace qualification is provided by either an explicit
      prefix or by default (<code>xmlns:</code>). So, to validate
      a traditional XML 1.0 document which does not use
      namespaces at all, you must provide a schema with no target
      namespace. Of course, there are many XML 1.0 documents that
      do not use namespaces, so there will be many schema
      documents written without target namespaces; you must be
      sure to give to your processor a schema document that
      corresponds to the vocabulary you wish to validate.
    </p>
    </div2>
    </div1>
    <div1 id="IPO"><head>Advanced Concepts II: The International Purchase Order</head>
    <p>
       The purchase order schema described in <specref ref="PO"/>
      was contained in a single document, and most
      of the schema constructions-- such as element declarations
      and type definitions-- were constructed from scratch. In
      reality, schema authors will want to compose schemas from
      constructions located in multiple documents, and to create new
      types based on existing types. In this section, we examine
      mechanisms that enable such compositions and creations.
    </p>
    <div2 id="SchemaInMultDocs"><head>A Schema in Multiple Documents</head>
    <p>
       As schemas become larger, it is often desirable to divide
      their content among several schema documents for purposes
      such as ease of maintenance, access control, and
      readability. For these reasons, we have taken the schema
      constructs concerning addresses out of <code><loc href="#po.xsd">po.xsd</loc></code>, and put them in a new file
      called <code><loc href="#address.xsd">address.xsd</loc></code>.
      The modified purchase order schema file is called <code> <loc href="#ipo.xsd">ipo.xsd</loc></code>:
    </p>
<note id="ipo.xsd" role="example"><p>The International Purchase Order Schema, ipo.xsd</p>
<eg xml:space="preserve">
&lt;schema targetNamespace="http://www.example.com/IPO"
        xmlns="http://www.w3.org/2001/XMLSchema"
        xmlns:ipo="http://www.example.com/IPO"&gt;

  &lt;annotation&gt;
    &lt;documentation xml:lang="en"&gt;
      International Purchase order schema for Example.com
      Copyright 2000 Example.com. All rights reserved.
    &lt;/documentation&gt;
  &lt;/annotation&gt;

  &lt;!-- include address constructs --&gt;
  &lt;include
    schemaLocation="http://www.example.com/schemas/address.xsd"/&gt;

  &lt;element name="purchaseOrder" type="ipo:PurchaseOrderType"/&gt;

  &lt;element name="comment" type="string"/&gt;

  &lt;complexType name="PurchaseOrderType"&gt;
    &lt;sequence&gt;
      &lt;element name="shipTo"     type="ipo:Address"/&gt;
      &lt;element name="billTo"     type="ipo:Address"/&gt;
      &lt;element ref="ipo:comment" minOccurs="0"/&gt;
      &lt;element name="items"      type="ipo:Items"/&gt;
    &lt;/sequence&gt;
    &lt;attribute name="orderDate" type="date"/&gt;
  &lt;/complexType&gt;

  &lt;complexType name="Items"&gt;
    &lt;sequence&gt;
      &lt;element name="item" minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;complexType&gt;
          &lt;sequence&gt;
            &lt;element name="productName" type="string"/&gt;
            &lt;element name="quantity"&gt;
              &lt;simpleType&gt;
                &lt;restriction base="positiveInteger"&gt;
                  &lt;maxExclusive value="100"/&gt;
                &lt;/restriction&gt;
              &lt;/simpleType&gt;
            &lt;/element&gt;
            &lt;element name="USPrice"    type="decimal"/&gt;
            &lt;element ref="ipo:comment" minOccurs="0"/&gt;
            &lt;element name="shipDate"   type="date" minOccurs="0"/&gt;
          &lt;/sequence&gt;
          &lt;attribute name="partNum" type="ipo:SKU" use="required"/&gt;
        &lt;/complexType&gt;
      &lt;/element&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;

  &lt;simpleType name="SKU"&gt;
    &lt;restriction base="string"&gt;
      &lt;pattern value="\d{3}-[A-Z]{2}"/&gt;
    &lt;/restriction&gt;
  &lt;/simpleType&gt;

&lt;/schema&gt;
</eg>
</note>
    <p>
       The file containing the address constructs is:
    </p>
<note id="address.xsd" role="example"><p>Addresses for International Purchase Order schema, address.xsd</p>
<eg xml:space="preserve">
&lt;schema targetNamespace="http://www.example.com/IPO"
        xmlns="http://www.w3.org/2001/XMLSchema"
        xmlns:ipo="http://www.example.com/IPO"&gt;

  &lt;annotation&gt;
    &lt;documentation xml:lang="en"&gt;
      Addresses for International Purchase order schema
      Copyright 2000 Example.com. All rights reserved.
    &lt;/documentation&gt;
  &lt;/annotation&gt;

  &lt;complexType name="Address"&gt;
    &lt;sequence&gt;
      &lt;element name="name"   type="string"/&gt;
      &lt;element name="street" type="string"/&gt;
      &lt;element name="city"   type="string"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;

  &lt;complexType name="USAddress"&gt;
    &lt;complexContent&gt;
      &lt;extension base="ipo:Address"&gt;
        &lt;sequence&gt;
          &lt;element name="state" type="ipo:USState"/&gt;
          &lt;element name="zip"   type="positiveInteger"/&gt;
        &lt;/sequence&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;

  &lt;complexType name="UKAddress"&gt;
    &lt;complexContent&gt;
      &lt;extension base="ipo:Address"&gt;
        &lt;sequence&gt;
          &lt;element name="postcode" type="ipo:UKPostcode"/&gt;
        &lt;/sequence&gt;
        &lt;attribute name="exportCode" type="positiveInteger" fixed="1"/&gt;
      &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;

  &lt;!-- other Address derivations for more countries --&gt;

  &lt;simpleType name="USState"&gt;
    &lt;restriction base="string"&gt;
      &lt;enumeration value="AK"/&gt;
      &lt;enumeration value="AL"/&gt;
      &lt;enumeration value="AR"/&gt;
      &lt;!-- and so on ... --&gt;
    &lt;/restriction&gt;
  &lt;/simpleType&gt;

  &lt;!-- simple type definition for UKPostcode --&gt;

&lt;/schema&gt;
</eg>
</note>
    <p id="ref23">The various purchase order and
      address constructions are now contained in two schema
      files, <code><loc href="#ipo.xsd">ipo.xsd</loc></code> and
      <code><loc href="#address.xsd">address.xsd</loc></code>. To
      include these constructions as part of the international
      purchase order schema, in other words to include them in
      the international purchase order's namespace, <code><loc href="#ipo.xsd">ipo.xsd</loc></code> contains the <code> <loc href="#element-include">include</loc></code> element:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;include schemaLocation="http://www.example.com/schemas/address.xsd"/&gt;
</eg>
</note>

    <p>
       The effect of this <code><loc href="#element-include">
      include</loc></code> element is to bring in the definitions
      and declarations contained in <code><loc href="#address.xsd">
      address.xsd</loc></code>, and make them available as part of
      the international purchase order schema target namespace.
      The one important caveat to using <code><loc href="#element-include">include</loc></code> is that the target
      namespace of the included components must be the same as
      the target namespace of the including schema, in this case
      <code> http://www.example.com/IPO</code>. Bringing in
      definitions and declarations using the <code><loc href="#element-include"> include</loc></code> mechanism
      effectively adds these components to the existing target
      namespace. In <specref ref="Redefine"/>, we
      describe a similar mechanism that enables you to modify
      certain components when they are brought in.
    </p>
    <p>
       In our example, we have shown only one including document
      and one included document. In practice it is possible to
      include more than one document using multiple <code><loc href="#element-include">include</loc></code> elements, and
      documents can include documents that themselves include
      other documents. However, nesting documents in this manner
      is legal only if all the
      included parts of the schema are declared with the same
      target namespace.
    </p>
    <p>
       Instance documents that conform to schema whose
      definitions span multiple schema documents need only
      reference the 'topmost' document and the common namespace,
      and it is the responsibility of the processor to gather
      together all the definitions specified in the various
      included documents. In our example above, the instance
      document <code><loc href="#ipo.xml">ipo.xml</loc></code> (see
      <specref ref="UseDerivInInstDocs"/>) references
      only the common target namespace, <code>
      http://www.example.com/IPO</code>, and (by implication) the one schema file
      <code>http://www.example.com/schemas/ipo.xsd</code>. The
      processor is responsible for obtaining the schema file
      <code><loc href="#address.xsd">address.xsd</loc></code>.
    </p>
    <p>
       In <specref ref="import"/> we describe how
      schemas can be used to validate content from more than one
      namespace.
    </p>
    </div2><div2 id="DerivExt"><head>Deriving Types by Extension</head>
    <p>
       To create our address constructs, we start by creating a
      complex type called <code>Address</code> in the usual way
      (see <code><loc href="#address.xsd">address.xsd</loc></code>).
      The <code>Address</code> type contains the basic elements
      of an address: a name, a street and a city. (Such a
      definition will not work for all countries, but it
      serves the purpose of our example.) From this starting
      point we derive two new complex types that contain all the
      elements of the original type plus additional elements that
      are specific to addresses in the US and the UK. The
      technique we use here to derive new (complex) address types
      by extending an existing type is the same technique we used
      in <phrase diff="del">in </phrase><specref ref="complexTfromSimpleT"/>,
      except that our base type here is a complex type whereas
      our base type in the previous section was a simple type.
    </p>
    <p id="ref53">
       We define the two new complex types, <code>
      USAddress</code> and <code>UKAddress</code>, using the
      <code><loc href="#element-complexType">complexType</loc></code>
      element. In addition, we indicate that the content models
      of the new types are complex, i.e. contain elements, by
      using the <code><loc href="#element-complexContent">
      complexContent</loc></code> element, and we indicate that we
      are extending the base type <code>Address</code> by the
      value of the <code><loc href="#attribute-base">
      base</loc></code> attribute on the <code><loc href="#element-extension">extension</loc></code> element.
    </p>
    <p>
       When a complex type is derived by extension, its effective
      content model is the content model of the base type plus
      the content model specified in the type derivation.
      Furthermore, the two content models are treated as two
      children of a sequential group. In the case of <code>
      UKAddress</code>, the content model of <code>
      UKAddress</code> is the content model of <code>
      Address</code> plus the declarations for a <code>
      postcode</code> element and an <code>exportCode</code>
      attribute. This is like defining the <code>UKAddress</code>
      from scratch as follows:
    </p>
<note id="EffectiveContentModel" role="example"><p><phrase diff="add">Effective Content Model of UKAddress</phrase></p>
<eg xml:space="preserve">
&lt;complexType name="UKAddress"&gt;
  &lt;sequence&gt;
    &lt;!-- content model of Address --&gt;
    &lt;element name="name"   type="string"/&gt;
    &lt;element name="street" type="string"/&gt;
    &lt;element name="city"   type="string"/&gt;

    &lt;!-- appended element declaration --&gt;
    &lt;element name="postcode" type="ipo:UKPostcode"/&gt;
  &lt;/sequence&gt;

  &lt;!-- appended attribute declaration --&gt;
  &lt;attribute name="exportCode" type="positiveInteger" fixed="1"/&gt;
&lt;/complexType&gt;
</eg>
</note>
    </div2>
    <div2 id="UseDerivInInstDocs"><head>Using Derived Types in Instance Documents</head>
    <p>
       In our example scenario, purchase orders are generated in
      response to customer orders which may involve shipping and
      billing addresses in different countries. The international
      purchase order, <code><loc href="#ipo.xml">ipo.xml</loc></code>
      below, illustrates one such case where goods are shipped to
      the UK and the bill is sent to a US address. Clearly it is
      better if the schema for international purchase orders
      does not have to spell out every possible combination of
      international addresses for billing and shipping, and even
      more so if we can add new complex types of international
      address simply by creating new derivations of <code>
      Address</code>.
    </p>
    <p id="ref24">XML Schema allows us to define the
      <code>billTo</code> and <code>shipTo</code> elements as
      <code>Address</code> types (see <code><loc href="#ipo.xsd">
      ipo.xsd</loc></code>) but to use instances of international
      addresses in place of instances of <code> Address</code>.
      In other words, an instance document whose content conforms
      to the <code>UKAddress</code> type will be valid if that
      content appears within the document at a location where an
      <code>Address</code> is expected (assuming the <code>
      UKAddress</code> content itself is valid). To make this
      feature of XML Schema work, and to identify exactly which
      derived type is intended, the derived type must be
      identified in the instance document. The type is identified
      using the <code><loc href="#attribute-xsitype">
      xsi:type</loc></code> attribute which is part of the XML
      Schema instance namespace. In the example, <code><loc href="#ipo.xml">ipo.xml</loc></code>, use of the <code>
      UKAddress</code> and <code>USAddress</code> derived types
      is identified through the values assigned to the <code><loc href="#attribute-xsitype">xsi:type</loc></code> attributes.
    </p>
<note id="ipo.xml" role="example"><p>An International Purchase order, ipo.xml</p>
<eg xml:space="preserve">
&lt;?xml version="1.0"?&gt;
&lt;ipo:purchaseOrder
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ipo="http://www.example.com/IPO"
  orderDate="1999-12-01"&gt;

  &lt;shipTo exportCode="1" xsi:type="ipo:UKAddress"&gt;
    &lt;name&gt;Helen Zoe&lt;/name&gt;
    &lt;street&gt;47 Eden Street&lt;/street&gt;
    &lt;city&gt;Cambridge&lt;/city&gt;
    &lt;postcode&gt;CB1 1JR&lt;/postcode&gt;
  &lt;/shipTo&gt;

  &lt;billTo xsi:type="ipo:USAddress"&gt;
    &lt;name&gt;Robert Smith&lt;/name&gt;
    &lt;street&gt;8 Oak Avenue&lt;/street&gt;
    &lt;city&gt;Old Town&lt;/city&gt;
    &lt;state&gt;PA&lt;/state&gt;
    &lt;zip&gt;95819&lt;/zip&gt;
  &lt;/billTo&gt;

  &lt;items&gt;
    &lt;item partNum="833-AA"&gt;
      &lt;productName&gt;Lapis necklace&lt;/productName&gt;
      &lt;quantity&gt;1&lt;/quantity&gt;
      &lt;USPrice&gt;99.95&lt;/USPrice&gt;
      &lt;ipo:comment&gt;Want this for the holidays&lt;!/ipo:comment&gt;
      &lt;shipDate&gt;1999-12-05&lt;/shipDate&gt;
    &lt;/item&gt;
  &lt;/items&gt;
&lt;/ipo:purchaseOrder&gt;
</eg>
</note>
    <p>
       In <specref ref="restrictingTypeDerivs"/> we describe
      how to prevent derived types from being used in this
      sort of substitution.
    </p>
    </div2>
    <div2 id="DerivByRestrict"><head>Deriving Complex Types by Restriction</head>
    <p>
       In addition to deriving new complex types by extending
      content models, it is possible to derive new types by
      restricting the content models of existing types.
      Restriction of complex types is conceptually the same as
      restriction of simple types, except that the restriction of
      complex types involves a type's declarations rather than
      the acceptable range of a simple type's values. A complex
      type derived by restriction is very similar to its base
      type, except that its declarations are more limited than
      the corresponding declarations in the base type. In fact,
      the values represented by the new type are a subset of the
      values represented by the base type (as is the case
      with restriction of simple types). In other words, an
      application prepared for the values of the base type would
      not be surprised by the values of the restricted type.
    </p>
    <p id="ref54">
       For example, suppose we want to update our definition of <phrase diff="del">
      the list of <code>items</code> in an international</phrase><phrase diff="add">a</phrase> purchase
      order so that it must contain <phrase diff="del"><emph>at least</emph> one <code>
      item</code> on order</phrase><phrase diff="add">a <code>comment</code></phrase>;
      the schema shown in <code> <loc href="#ipo.xsd">ipo.xsd</loc></code> allows a<phrase diff="del">n
      <code>items</code></phrase><phrase diff="add"> <code>purchaseOrder</code></phrase>
      element to appear without any child <phrase diff="del"><code>item</code></phrase>
      <phrase diff="add"><code>comment</code></phrase>
      elements. To create our new <phrase diff="del"><code>ConfirmedItems</code></phrase>
      <phrase diff="add"><code>RestrictedPurchaseOrderType</code></phrase>
      type, we define the new type in the usual way, indicate
      that it is derived by restriction from the base type <phrase diff="del"><code>
      Items</code></phrase>
      <phrase diff="add"><code>PurchaseOrderType</code></phrase>
      , and provide a new (more restrictive) value for
      the minimum number of <phrase diff="del"><code>item</code></phrase>
      <phrase diff="add"><code>comment</code></phrase> element
      occurrences. Notice that types derived by restriction must
      repeat all the <phrase diff="add">particle</phrase> components<phrase diff="add">
      (element declarations, model groups, and wildcards)</phrase> of the base type definition that
      are to be included in the derived type<phrase diff="del">:</phrase><phrase diff="add">.  However,
      attribute declarations do not need to be repeated in the derived type definition; in this example, <code>RestrictedPurchaseOrderType</code> will inherit the
      <code>orderDate</code> attribute declaration from <code>PurchaseOrderType</code>.</phrase>
    </p>
<note id="DerivingRestrictedPOType" role="example"><p><phrase diff="del">Deriving ConfirmedItems by Restriction from Items</phrase>
    <phrase diff="add">Deriving RestrictedPurchaseOrderType by Restriction from PurchaseOrderType</phrase></p>
<eg xml:space="preserve">
<phrase diff="del">&lt;complexType name="ConfirmedItems"&gt;
  &lt;complexContent&gt;
    &lt;restriction base="ipo:Items"&gt;
      &lt;sequence&gt;

         &lt;!-- item element is different than in Items --&gt;
         &lt;element name="item" minOccurs="1" maxOccurs="unbounded"&gt;

         &lt;!-- remainder of definition is same as Items --&gt;
           &lt;complexType&gt;
             &lt;sequence&gt;
               &lt;element name="productName" type="string"/&gt;
               &lt;element name="quantity"&gt;
                 &lt;simpleType&gt;
                   &lt;restriction base="positiveInteger"&gt;
                     &lt;maxExclusive value="100"/&gt;
                   &lt;/restriction&gt;
                 &lt;/simpleType&gt;
               &lt;/element&gt;
               &lt;element name="USPrice"    type="decimal"/&gt;
               &lt;element ref="ipo:comment" minOccurs="0"/&gt;
               &lt;element name="shipDate"   type="date" minOccurs="0"/&gt;
            &lt;/sequence&gt;
            &lt;attribute name="partNum" type="ipo:SKU" use="required"/&gt;
          &lt;/complexType&gt;
        &lt;/element&gt;

      &lt;/sequence&gt;
    &lt;/restriction&gt;
  &lt;/complexContent&gt;
&lt;/complexType&gt;</phrase>
<phrase diff="add">&lt;complexType name="RestrictedPurchaseOrderType"&gt;
  &lt;complexContent&gt;
    &lt;restriction base="ipo:PurchaseOrderType"&gt;
      &lt;sequence&gt;
        &lt;element name="shipTo" type="ipo:Address"/&gt;
        &lt;element name="billTo" type="ipo:Address"/&gt;
        &lt;element ref="ipo:comment" minOccurs="1"/&gt;
        &lt;element name="items"  type="ipo:Items"/&gt;
      &lt;/sequence&gt;
    &lt;/restriction&gt;
  &lt;/complexContent&gt;
&lt;/complexType&gt;</phrase>
</eg>
</note>
    <p>
       This change<phrase diff="del">, requiring at least one child element rather
      than allowing zero or more child elements,</phrase> narrows the
      allowable number of <phrase diff="del">child</phrase><phrase diff="add">
      <code>comment</code></phrase> elements from a minimum of 0 to a
      minimum of 1. Note that all <phrase diff="del"><code>ConfirmedItems</code></phrase>
      <phrase diff="add"><code>RestrictedPurchaseOrderType</code></phrase>
      type elements will also be acceptable as <phrase diff="del"><code>Item</code></phrase>
      <phrase diff="add"><code>PurchaseOrderType</code></phrase>
      type elements.
    </p>
    <p>
       To further illustrate restriction, <loc href="#restrictsTable">Table 3</loc> shows several examples of
      how element and attribute declarations within type
      definitions may be restricted (the table shows element
      syntax although the first three examples are equally valid
      attribute restrictions).
    </p>
    <table id="restrictsTable" border="2" width="100%" summary="examples of restriction">
      <tbody>
        <tr>
          <th align="left" colspan="3">Table 3. Restriction Examples</th>
        </tr>
        <tr>
          <th>Base</th>
          <th>Restriction<phrase diff="add">(s)</phrase></th>
          <th>Notes</th>
        </tr>
        <tr>
          <td></td>
          <td align="center">default="1"</td>
          <td>setting a default value where none was previously
            given</td>
        </tr>
        <tr>
          <td></td>
          <td align="center">fixed="100"</td>
          <td>setting a fixed value where none was previously given</td>
        </tr>
        <tr>
          <td></td>
          <td align="center">type="<loc href="#string">string</loc>"</td>
          <td>specifying a type where none was previously given</td>
        </tr>
        <tr>
          <th>(<loc href="#attribute-minOccurs">minOccurs</loc>, <loc href="#attribute-maxOccurs">maxOccurs</loc>)</th>
          <th>(<loc href="#attribute-minOccurs">minOccurs</loc>, <loc href="#attribute-maxOccurs">maxOccurs</loc>)</th>
          <th></th>
        </tr>
        <tr>
          <td align="center">(0, 1)</td>
          <td align="center">(0, 0)</td>
          <td>exclusion of an optional component; this may also be
            accomplished by omitting the component's declaration
            from the restricted type definition</td>
        </tr>
        <tr>
          <td align="center"><phrase diff="add">(0, 1)</phrase></td>
          <td align="center"><phrase diff="add">(1, 1)</phrase></td>
          <td><phrase diff="add">making an optional component required</phrase></td>
        </tr>
        <tr>
          <td align="center">(0, unbounded)</td>
          <td align="center">
            <table border="0"><tbody>
              <tr><td align="center">(0, 0)</td></tr>
              <tr><td align="center">(0, 37)</td></tr>
              <tr><td align="center"><phrase diff="add">(1, 37)</phrase></td></tr>
            </tbody></table>
          </td>
          <td></td>
        </tr>
        <tr>
          <td align="center">(1, 9)</td>
          <td align="center">
            <table border="0"><tbody>
              <tr><td align="center">(1, 8)</td></tr>
              <tr><td align="center">(2, 9)</td></tr>
              <tr><td align="center">(4, 7)</td></tr>
              <tr><td align="center">(3, 3)</td></tr>
            </tbody></table>
          </td>
          <td></td>
        </tr>
        <tr>
          <td align="center">(1, unbounded)</td>
          <td align="center">
            <table border="0"><tbody>
              <tr><td align="center">(1, 12)</td></tr>
              <tr><td align="center">(3, unbounded)</td></tr>
              <tr><td align="center">(6, 6)</td></tr>
            </tbody></table>
          </td>
          <td></td>
        </tr>
        <tr>
          <td align="center">(1, 1)</td>
          <td align="center"><phrase diff="add">(1, 1)</phrase></td>
          <td>cannot <phrase diff="add">further </phrase>restrict <loc href="#attribute-minOccurs">minOccurs</loc> or <loc href="#attribute-maxOccurs">maxOccurs</loc></td>
        </tr>
      </tbody>
    </table>
    </div2>
    <div2 id="Redefine"><head>Redefining Types &amp; Groups</head>
    <p id="ref52">
       In <specref ref="SchemaInMultDocs"/> we
      described how to include definitions and declarations
      obtained from external schema files having the same target
      namespace. The <code><loc href="#element-include">
      include</loc></code> mechanism enables you to use externally
      created schema components "as-is", that is, without any
      modification. We have just described how to derive new
      types by extension and by restriction, and the <code><loc href="#element-redefine">redefine</loc></code> mechanism we
      describe here enables you to redefine simple and
      complex types, groups, and attribute groups that are
      obtained from external schema files. Like the <code><loc href="#element-include">include</loc></code> mechanism,
      <code><loc href="#element-redefine">redefine</loc></code>
      requires the external components to be in the same target
      namespace as the redefining schema, although external
      components from schemas that have no namespace can also be
      redefined. In the latter cases, the redefined components
      become part of the redefining schema's target namespace.
    </p>
    <p>
       To illustrate the <code><loc href="#element-redefine">
      redefine</loc></code> mechanism, we use it instead of
      the <code><loc href="#element-include">include</loc></code>
      mechanism in the International Purchase Order schema,
      <code><loc href="#ipo.xsd">ipo.xsd</loc></code>, and we
      use it to modify the definition of the complex type <code>
      Address</code> contained in <code><loc href="#address.xsd">
      address.xsd</loc></code>:
    </p>
<note id="UsingRedefineInInternational" role="example"><p>Using redefine in the International Purchase Order</p>
<eg xml:space="preserve">
&lt;schema targetNamespace="http://www.example.com/IPO"
        xmlns="http://www.w3.org/2001/XMLSchema"
        xmlns:ipo="http://www.example.com/IPO"&gt;

  &lt;!-- bring in address constructs --&gt;
  &lt;redefine
    schemaLocation="http://www.example.com/schemas/address.xsd"&gt;

    &lt;!-- redefinition of Address --&gt;
    &lt;complexType name="Address"&gt;
      &lt;complexContent&gt;
        &lt;extension base="ipo:Address"&gt;
          &lt;sequence&gt;
            &lt;element name="country" type="string"/&gt;
          &lt;/sequence&gt;
        &lt;/extension&gt;
      &lt;/complexContent&gt;
    &lt;/complexType&gt;

  &lt;/redefine&gt;

  &lt;!-- etc. --&gt;

&lt;/schema&gt;
</eg>
</note>
    <p>
       The <code><loc href="#element-redefine">redefine</loc></code>
      element acts very much like the <code><loc href="#element-include">include</loc></code> element as it includes
      all the declarations and definitions from the <code><loc href="#address.xsd">address.xsd</loc></code> file. The
      complex type definition of <code>Address</code> uses the
      familiar extension syntax to add a <code>country</code>
      element to the definition of <code>Address</code>. However,
      note that the base type is also <code>Address</code>.
      Outside of the <code><loc href="#element-redefine">
      redefine</loc></code> element, any such attempt to define a
      complex type with the same name (and in the same namespace)
      as the base from which it is being derived would cause an
      error. But in this case, there is no error, and the
      extended definition of <code>Address</code> becomes the
      only definition of <code>Address</code>.
    </p>
    <p>
       Now that <code>Address</code> has been redefined, the
      extension applies to all schema components that make use of
      <code>Address</code>. For example, <code><loc href="#address.xsd">
      address.xsd</loc></code> contains definitions of international
      address types that are derived from <code>Address</code>.
      These derivations reflect the redefined <code>
      Address</code> type, as shown in the following snippet:
    </p>
<note id="SnippetOfRedefinedAddress" role="example"><p>Snippet of <loc href="#ipo.xml">ipo.xml</loc> using Redefined Address</p>
<eg xml:space="preserve">
 ....
 &lt;shipTo exportCode="1" xsi:type="ipo:UKAddress"&gt;
   &lt;name&gt;Helen Zoe&lt;/name&gt;
   &lt;street&gt;47 Eden Street&lt;/street&gt;
   &lt;city&gt;Cambridge&lt;/city&gt;
   &lt;!-- country was added to Address which is base type of UKAddress --&gt;
   &lt;country&gt;United Kingdom&lt;/country&gt;
   &lt;!-- postcode was added as part of UKAddress --&gt;
   &lt;postcode&gt;CB1 1JR&lt;/postcode&gt;
 &lt;/shipTo&gt;
 ....
</eg>
</note>
    <p>
       Our example has been carefully constructed so that the
      redefined <code>Address</code> type does not conflict in
      any way with the types that are derived from the original
      <code>Address</code> definition. But note that it would be
      very easy to create a conflict. For example, if the
      international address type derivations had extended <code>
      Address</code> by adding a <code>country</code> element,
      then the redefinition of <code>Address</code> would be
      adding an element of the same name to the content model of
      <code>Address</code>. It is illegal to have two elements of
      the same name (and in the same target namespace) but
      different types in a content model, and so the attempt to
      redefine <code>Address</code> would cause an error. In
      general, <code><loc href="#element-redefine">
      redefine</loc></code> does not protect you from such errors,
      and it should be used cautiously.
    </p>
    </div2>
    <div2 id="SubsGroups"><head>Substitution Groups</head>
    <p id="ref25">XML Schema provides a mechanism,
      called substitution groups, that allows elements to be
      substituted for other elements. More specifically, elements
      can be assigned to a special group of elements that are
      said to be substitutable for a particular named element
      called the head element. (Note that the head element
      <phrase diff="add"> as well as the substitutable
      elements</phrase>must
      be declared as <phrase diff="del">a </phrase>global
      element<phrase diff="add">s</phrase>.) To illustrate, we
      declare two elements called <code> customerComment</code>
      and <code> shipComment</code> and assign them to a
      substitution group whose head element is <code>
      comment</code>, and so <code> customerComment</code> and
      <code>shipComment</code> can be used anyplace that we are
      able to use <code> comment</code>. Elements in a
      substitution group must have the same type as the head
      element, or they can have a type that has been derived from
      the head element's type. To declare these two new elements,
      and to make them substitutable for the <code>
      comment</code> element, we use the following syntax:
    </p>
<note id="DeclaringElementsSubstitutable" role="example"><p>Declaring Elements Substitutable for comment</p>
<eg xml:space="preserve">
&lt;element name="shipComment" type="string"
         substitutionGroup="ipo:comment"/&gt;
&lt;element name="customerComment" type="string"
         substitutionGroup="ipo:comment"/&gt;
</eg>
</note>
    <p>
       When these declarations are added to the international
      purchase order schema, <code>shipComment</code> and
      <code>customerComment</code> can be substituted for
      <code>comment</code> in the instance document, for example:
    </p>
<note id="SnippetOfSubstitutedElements" role="example"><p>Snippet of <loc href="#ipo.xml">ipo.xml</loc> with
            Substituted Elements</p>
<eg xml:space="preserve">
....
&lt;items&gt;
  &lt;item partNum="833-AA"&gt;
    &lt;productName&gt;Lapis necklace&lt;/productName&gt;
    &lt;quantity&gt;1&lt;/quantity&gt;
    &lt;USPrice&gt;99.95&lt;/USPrice&gt;
    &lt;ipo:shipComment&gt;
      Use gold wrap if possible
    &lt;/ipo:shipComment&gt;
    &lt;ipo:customerComment&gt;
      Want this for the holidays!
    &lt;/ipo:customerComment&gt;
    &lt;shipDate&gt;1999-12-05&lt;/shipDate&gt;
  &lt;/item&gt;
&lt;/items&gt;
....
</eg>
</note>
    <p>
       Note that when an instance document contains element
      substitutions whose types are derived from those of their
      head elements, it is <emph>not</emph> necessary to identify the
      derived types using the <code><loc href="#attribute-xsitype">xsi:type</loc></code> construction that
      we described in <specref ref="UseDerivInInstDocs"/>.
    </p>
    <p>
       The existence of a substitution group does not require any
      of the elements in that class to be used, nor does it
      preclude use of the head element. It simply provides a
      mechanism for allowing elements to be used interchangeably.
    </p>
    </div2>
    <div2 id="abstract"><head>Abstract Elements and Types</head>
    <p id="ref26">XML Schema provides a mechanism to
      force substitution for a particular element or type. When
      an element or type is declared to be "abstract", it cannot
      be used in an instance document. When an element is
      declared to be abstract, a member of that element's
      substitution group must appear in the instance document.
      When an element's corresponding type definition is declared
      as abstract, all instances of that element must use <code>
      <loc href="#attribute-xsitype">xsi:type</loc></code> to
      indicate a derived type that is not abstract.
    </p>
    <p>
       In the substitution group example we described in <specref ref="SubsGroups"/>, it would be useful to
      specifically disallow use of the <code>comment</code>
      element so that instances must make use of the <code>
      customerComment</code> and <code> shipComment</code>
      elements. To declare the <code>comment</code> element
      abstract, we modify its original declaration in the
      international purchase order schema, <code><loc href="#ipo.xsd">ipo.xsd</loc></code>, as follows:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;element name="comment" type="string" abstract="true"/&gt;
</eg>
</note>
    <p>
       With <code>comment</code> declared as abstract, instances
      of international purchase orders are now only valid if they
      contain <code>customerComment</code> and <code>
      shipComment</code> elements.
    </p>
    <p>
       Declaring an element as abstract requires the use of a
      substitution group. Declaring a type as abstract simply
      requires the use of a type derived from it (and identified
      by the <code><loc href="#attribute-xsitype">
      xsi:type</loc></code> attribute) in the instance document.
      Consider the following schema definition:
    </p>
<note id="SchemaForVehicles" role="example"><p>Schema for Vehicles</p>
<eg xml:space="preserve">
&lt;schema xmlns="http://www.w3.org/2001/XMLSchema"
           targetNamespace="http://cars.example.com/schema"
           xmlns:target="http://cars.example.com/schema"&gt;

  &lt;complexType name="Vehicle" abstract="true"/&gt;

  &lt;complexType name="Car"&gt;
    &lt;complexContent&gt;
      &lt;extension base="target:Vehicle"/&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;

  &lt;complexType name="Plane"&gt;
    &lt;complexContent&gt;
      &lt;extension base="target:Vehicle"/&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;

  &lt;element name="transport" type="target:Vehicle"/&gt;
&lt;/schema&gt;
</eg>
</note>
    <p>
       The <code>transport</code> element is not abstract,
      therefore it can appear in instance documents. However,
      because its type definition is abstract, it may never
      appear in an instance document without an <code> <loc href="#attribute-xsitype">xsi:type</loc></code> attribute that
      refers to a derived type. That means the following is not
      schema-valid:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;transport xmlns="http://cars.example.com/schema"/&gt;
</eg>
</note>
    <p>
       because the <code>transport</code> element's type is
      abstract. However, the following is schema-valid:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;transport xmlns="http://cars.example.com/schema"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:type="Car"/&gt;
</eg>
</note>
    <p>
       because it uses a non-abstract type that is substitutable
      for <code>Vehicle</code>.
    </p>
    </div2>
    <div2 id="restrictingTypeDerivs"><head>Controlling the Creation &amp; Use of Derived Types</head>
    <p id="ref27">So far, we have been able to derive
      new types and use them in instance documents without any
      restraints. In reality, schema authors will sometimes want
      to control derivations of particular types, and the use of
      derived types in instances.
    </p>
    <p>
       XML Schema provides a couple of mechanisms that control
      the derivation of types. One of these mechanisms allows the
      schema author to specify that for a particular complex
      type, new types may not be derived from it, either (a) by
      restriction, (b) by extension, or (c) at all. To
      illustrate, suppose we want to prevent any derivation of
      the <code> Address</code> type by restriction because we
      intend for it only to be used as the base for extended
      types such as <code>USAddress</code> and <code>
      UKAddress</code>. To prevent any such derivations, we
      slightly modify the original definition of <code>
      Address</code> as follows:
    </p>
<note id="PreventingDerivationsByRestriction" role="example"><p>Preventing Derivations by Restriction of Address</p>
<eg xml:space="preserve">
&lt;complexType name="Address" final="restriction"&gt;
  &lt;sequence&gt;
    &lt;element name="name"   type="string"/&gt;
    &lt;element name="street" type="string"/&gt;
    &lt;element name="city"   type="string"/&gt;
  &lt;/sequence&gt;
&lt;/complexType&gt;
</eg>
</note>
    <p id="ref43">The <code>restriction</code> value of
      the <code><loc href="#attribute-final">final</loc></code>
      attribute prevents derivations by restriction. Preventing
      derivations at all, or by extension, are indicated by the
      values <code>#all</code> and <code> extension</code>
      respectively. Moreover, there exists an optional <code><loc href="#attribute-finalDefault">finalDefault</loc></code> attribute
      on the <code><loc href="#element-schema">schema</loc></code>
      element whose value can be one of the values allowed for
      the <code><loc href="#attribute-final">final</loc></code>
      attribute. The effect of specifying the <code><loc href="#attribute-finalDefault">finalDefault</loc></code> attribute
      is equivalent to specifying a <code><loc href="#attribute-final">final</loc></code> attribute on every type
      definition and element declaration in the schema.
    </p>
    <p id="ref44">Another type-derivation mechanism
      controls which facets can be applied in the derivation of a
      new simple type. When a simple type is defined, the <code>
      <loc href="#attribute-facet-fixed">fixed</loc></code> attribute
      may be applied to any of its facets to prevent a derivation
      of that type from modifying the value of the fixed facets.
      For example, we can define a <code>Postcode</code> simple
      type as:
    </p>
<note id="PreventingChangestoFacets" role="example"><p>Preventing Changes to Simple Type Facets</p>
<eg xml:space="preserve">
&lt;simpleType name="Postcode"&gt;
  &lt;restriction base="string"&gt;
    &lt;length value="7" fixed="true"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;
</eg>
</note>
    <p>
       Once this simple type has been defined, we can derive a
      new postal code type in which we apply a facet not fixed in
      the base definition, for example:
    </p>
<note id="LegalDerivationFromPostcode" role="example"><p>Legal Derivation from Postcode</p>
<eg xml:space="preserve">
&lt;simpleType name="UKPostcode"&gt;
  &lt;restriction base="ipo:Postcode"&gt;
    &lt;pattern value="[A-Z]{2}\d\s\d[A-Z]{2}"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;
</eg>
</note>
    <p>
       However, we cannot derive a new postal code in which we
      re-apply any facet that was fixed in the base definition:
    </p>
<note id="IllegalDerivationFromPostcode" role="example"><p>Illegal Derivation from Postcode</p>
<eg xml:space="preserve">
&lt;simpleType name="UKPostcode"&gt;
  &lt;restriction base="ipo:Postcode"&gt;
    &lt;pattern value="[A-Z]{2}\d\d[A-Z]{2}"/&gt;
    &lt;!-- illegal attempt to modify facet fixed in base type --&gt;
    &lt;length value="6" fixed="true"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;
</eg>
</note>
    <p id="ref28">In addition to the mechanisms that
      control type derivations, XML Schema provides a mechanism
      that controls which derivations and substitution groups may
      be used in instance documents. In <specref ref="UseDerivInInstDocs"/>, we described how the
      derived types, <code> USAddress</code> and <code>
      UKAddress</code>, could be used by the <code>shipTo</code>
      and <code>billTo</code> elements in instance documents.
      These derived types can replace the content model provided
      by the <code> Address</code> type because they are derived
      from the <code>Address</code> type. However, replacement by
      derived types can be controlled using the <code><loc href="#attribute-block">block</loc></code> attribute in a type
      definition. For example, if we want to block any
      derivation-by-restriction from being used in place of
      <code>Address</code> (perhaps for the same reason we
      defined <code>Address</code> with <code> <loc href="#attribute-final">final</loc>="restriction"</code>), we can
      modify the original definition of <code>Address</code> as
      follows:
    </p>
<note id="PreventingDerivationsInInstance" role="example"><p>Preventing Derivations by Restriction of Address in
            the Instance</p>
<eg xml:space="preserve">
&lt;complexType name="Address" block="restriction"&gt;
  &lt;sequence&gt;
    &lt;element name="name"   type="string"/&gt;
    &lt;element name="street" type="string"/&gt;
    &lt;element name="city"   type="string"/&gt;
  &lt;/sequence&gt;
&lt;/complexType&gt;
</eg>
</note>
    <p id="ref42">The <code>restriction</code> value on
      the <code> <loc href="#attribute-block">block</loc></code>
      attribute prevents derivations-by-restriction from
      replacing <code>Address</code> in an instance. However, it
      would not prevent <code>UKAddress</code> and <code>
      USAddress</code> from replacing <code>Address</code>
      because they were derived by extension. Preventing
      replacement by derivations at all, or by
      derivations-by-extension, are indicated by the values
      <code>#all</code> and <code>extension</code> respectively.
      As with <code><loc href="#attribute-final">final</loc></code>,
      there exists an optional <code><loc href="#attribute-blockDefault">blockDefault</loc></code> attribute
      on the <code><loc href="#element-schema">schema</loc></code>
      element whose value can be one of the values allowed for
      the <code><loc href="#attribute-block">block</loc></code>
      attribute. The effect of specifying the <code><loc href="#attribute-blockDefault">blockDefault</loc></code> attribute
      is equivalent to specifying a <code><loc href="#attribute-block">block</loc></code> attribute on every type
      definition and element declaration in the schema.
    </p>
    </div2></div1>
    <div1 id="quartelyReport"><head>Advanced Concepts III: The Quarterly Report</head>
    <p>
       The home-products ordering and billing application can
      generate ad-hoc reports that summarize how many of which
      types of products have been billed on a per region basis.
      An example of such a report, one that covers the fourth
      quarter of 1999, is shown in <code><loc href="#Q99.xml">
      4Q99.xml</loc></code>.
    </p>
    <p>
       Notice that in this section we use qualified elements in
      the schema, and default namespaces where possible in the
      instances.
    </p>
<note id="Q99.xml" role="example"><p>Quarterly Report, 4Q99.xml</p>
<eg xml:space="preserve">
&lt;purchaseReport
  xmlns="http://www.example.com/Report"
  period="P3M" periodEnding="1999-12-31"&gt;

  &lt;regions&gt;
    &lt;zip code="95819"&gt;
      &lt;part number="872-AA" quantity="1"/&gt;
      &lt;part number="926-AA" quantity="1"/&gt;
      &lt;part number="833-AA" quantity="1"/&gt;
      &lt;part number="455-BX" quantity="1"/&gt;
    &lt;/zip&gt;
    &lt;zip code="63143"&gt;
      &lt;part number="455-BX" quantity="4"/&gt;
    &lt;/zip&gt;
  &lt;/regions&gt;

  &lt;parts&gt;
    &lt;part number="872-AA"&gt;Lawnmower&lt;/part&gt;
    &lt;part number="926-AA"&gt;Baby Monitor&lt;/part&gt;
    &lt;part number="833-AA"&gt;Lapis Necklace&lt;/part&gt;
    &lt;part number="455-BX"&gt;Sturdy Shelves&lt;/part&gt;
  &lt;/parts&gt;

&lt;/purchaseReport&gt;
</eg>
</note>
    <p>
       The report lists, by number and quantity, the parts billed
      to various zip codes, and it provides a description of each
      part mentioned. In summarizing the billing data, the
      intention of the report is clear and the data is
      unambiguous because a number of constraints are in effect.
      For example, each zip code appears only once (uniqueness
      constraint). Similarly, the description of every billed
      part appears only once although parts may be billed to
      several zip codes (referential constraint), see for example
      part number <code>455-BX</code>. In the following sections, we'll see
      how to specify these constraints using XML Schema.
    </p>
<note id="report.xsd" role="example"><p>The Report Schema, report.xsd</p>
<eg xml:space="preserve">
&lt;schema targetNamespace="http://www.example.com/Report"
        xmlns="http://www.w3.org/2001/XMLSchema"
        xmlns:r="http://www.example.com/Report"
        xmlns:xipo="http://www.example.com/IPO"
        elementFormDefault="qualified"&gt;

  &lt;!-- for SKU --&gt;
  &lt;import namespace="http://www.example.com/IPO"/&gt;

  &lt;annotation&gt;
    &lt;documentation xml:lang="en"&gt;
      Report schema for Example.com
      Copyright 2000 Example.com. All rights reserved.
    &lt;/documentation&gt;
  &lt;/annotation&gt;

  &lt;element name="purchaseReport"&gt;
    &lt;complexType&gt;
      &lt;sequence&gt;
        &lt;element name="regions" type="r:RegionsType"<phrase diff="add">/</phrase>&gt;
          <phrase diff="del">&lt;keyref name="dummy2" refer="r:pNumKey"&gt;
            &lt;selector xpath="r:zip/r:part"/&gt;
            &lt;field xpath="@number"/&gt;
          &lt;/keyref&gt;
        &lt;/element&gt;</phrase>
        &lt;element name="parts" type="r:PartsType"/&gt;
      &lt;/sequence&gt;
      &lt;attribute name="period"       type="duration"/&gt;
      &lt;attribute name="periodEnding" type="date"/&gt;
    &lt;/complexType&gt;

    &lt;unique name="dummy1"&gt;
      &lt;selector xpath="r:regions/r:zip"/&gt;
      &lt;field xpath="@code"/&gt;
    &lt;/unique&gt;

    &lt;key name="pNumKey"&gt;
      &lt;selector xpath="r:parts/r:part"/&gt;
      &lt;field xpath="@number"/&gt;
    &lt;/key&gt;

    <phrase diff="add">&lt;keyref name="dummy2" refer="r:pNumKey"&gt;
      &lt;selector xpath="r:regions/r:zip/r:part"/&gt;
      &lt;field xpath="@number"/&gt;
    &lt;/keyref&gt;</phrase>

  &lt;/element&gt;

  &lt;complexType name="RegionsType"&gt;
    &lt;sequence&gt;
      &lt;element name="zip" maxOccurs="unbounded"&gt;
        &lt;complexType&gt;
          &lt;sequence&gt;
            &lt;element name="part" maxOccurs="unbounded"&gt;
              &lt;complexType&gt;
                &lt;complexContent&gt;
                  &lt;restriction base="anyType"&gt;
                    &lt;attribute name="number"   type="xipo:SKU"/&gt;
                    &lt;attribute name="quantity" type="positiveInteger"/&gt;
                  &lt;/restriction&gt;
                &lt;/complexContent&gt;
              &lt;/complexType&gt;
            &lt;/element&gt;
          &lt;/sequence&gt;
          &lt;attribute name="code" type="positiveInteger"/&gt;
        &lt;/complexType&gt;
      &lt;/element&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;

  &lt;complexType name="PartsType"&gt;
    &lt;sequence&gt;
      &lt;element name="part" maxOccurs="unbounded"&gt;
        &lt;complexType&gt;
          &lt;simpleContent&gt;
            &lt;extension base="string"&gt;
              &lt;attribute name="number" type="xipo:SKU"/&gt;
            &lt;/extension&gt;
          &lt;/simpleContent&gt;
        &lt;/complexType&gt;
      &lt;/element&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;

&lt;/schema&gt;
</eg>
</note>
    <div2 id="specifyingUniqueness"><head>Specifying Uniqueness</head>
    <p id="ref29">XML Schema enables us to indicate
      that any attribute or element value must be unique within a
      certain scope. To indicate that one particular attribute or
      element value is unique, we use the <code><loc href="#element-unique">unique</loc></code> element first to
      "select" a set of elements, and then to identify the
      attribute or element "field" relative to each selected
      element that has to be unique within the scope of the set
      of selected elements. In the case of our report schema,
      <code><loc href="#report.xsd">report.xsd</loc></code>, the
      <code><loc href="#element-selector">selector</loc></code>
      element's <code><loc href="#attribute-xpath">xpath</loc></code>
      attribute contains an XPath expression,
      <phrase diff="add"><code>r:</code></phrase><code>regions/</code><phrase diff="add"><code>r:</code></phrase><code>zip</code>,
      that selects a list of all the
      <code>zip</code> elements in a report instance. Likewise, the
      <code><loc href="#element-field">field</loc></code> element's
      <code><loc href="#attribute-xpath">xpath</loc></code> attribute
      contains a second XPath expression, <code>@code</code>,
      that specifies that the <code>code</code> attribute values
      of those elements must be unique. Note that the XPath
      expressions limit the scope of what must be unique. The
      report might contain another <code>code</code> attribute,
      but its value does not have to be unique because it lies
      outside the scope defined by the XPath expressions. Also
      note that the XPath expressions you can use in the
      <code><loc href="#attribute-xpath">xpath</loc></code> attribute
      are limited to a <xspecref href="&part1;#coss-identity-constraint">subset</xspecref>
      of the full XPath language defined in <xspecref href="http://www.w3.org/TR/1999/REC-xpath-19991116">XML Path Language 1.0</xspecref>.
    </p>
    <p>
       We can also indicate combinations of fields that
      must be unique. <phrase diff="del">To illustrate, suppose we can relax the
      constraint that zip codes may only be listed once, although
      we still want to enforce the constraint that any product is
      listed only once within a given zip code. We could achieve
      such a constraint by specifying that the combination of zip
      code and product number must be unique. From the report
      document, <code> <loc href="#Q99.xml">4Q99.xml</loc></code>,
      the combined values of zip <code>code</code> and <code>
      number</code> would be: {<code>95819 872-AA</code>},
      {<code>95819 926-AA</code>}, {<code>95819 833-AA</code>},
      {<code>95819 455-BX</code>}, and {<code>63143 455-BX</code>}.
      Clearly, these combinations do not distinguish between zip
      <code>code</code> and <code>number</code> combinations
      derived from single or multiple listings of any particular
      zip, but the combinations would unambiguously represent a
      product listed more than once within a single zip. In other
      words, a schema processor could detect violations of the
      uniqueness constraint.</phrase><phrase diff="add">Going
      back to our purchase order example, suppose we want each item to have a
      unique combination of part number and product name.  We could achieve
      such a constraint by specifying that for each <code>item</code> element,
      the combined values of its <code>partNum</code> attribute
      and its <code>productName</code> child must be unique.</phrase>
    </p>
    <p>
      To define combinations of values, we simply <phrase diff="del">add</phrase>
      <phrase diff="add">use multiple</phrase> <code> <loc href="#element-field">field</loc></code> elements to identify
      all the values involved<phrase diff="del">. So, to add the part number value
      to our existing definition, we add a new <code><loc href="#element-field">field</loc></code> element whose <code><loc href="#attribute-xpath">xpath</loc></code> attribute value,
      <code>r:part/@number</code>, identifies the <code>
      number</code> attribute of <code>part</code> elements that
      are children of the <code>zip</code> elements identified by
      <code>r:regions/r:zip</code></phrase>:
    </p>
<note id="UniqueComposedValue" role="example"><p>A Unique Composed Value</p>
<eg xml:space="preserve">
<phrase diff="del"> &lt;unique name="dummy1"&gt;
  &lt;selector xpath="r:regions/r:zip"/&gt;
  &lt;field    xpath="@code"/&gt;
  &lt;field    xpath="r:part/@number"/&gt;
 &lt;/unique&gt;</phrase>
<phrase diff="add">&lt;xsd:element name="items" type="Items"&gt;
  &lt;xsd:unique name="partNumAndName"&gt;
    &lt;xsd:selector xpath="item"/&gt;
    &lt;xsd:field    xpath="@partNum"/&gt;
    &lt;xsd:field    xpath="productName"/&gt;
  &lt;/xsd:unique&gt;
&lt;/xsd:element&gt;</phrase>
</eg>
</note>
    </div2>
    <div2 id="specifyingKeysAndtheirRefs"><head>Defining Keys &amp; their References</head>
    <p id="ref30">In the 1999 quarterly report, the
      description of every billed part appears only once. We
      could enforce this constraint using <code><loc href="#element-unique">unique</loc></code>, however, we also want
      to ensure that every part-quantity element listed under a
      zip code has a corresponding part description. We enforce
      the constraint using the <code><loc href="#element-key">
      key</loc></code> and <code><loc href="#element-keyref">
      keyref</loc></code> elements. The report schema, <code><loc href="#report.xsd">report.xsd</loc></code>, shows that the
      <code><loc href="#element-key">key</loc></code> and <code><loc href="#element-keyref">keyref</loc></code> constructions are
      applied using almost the same syntax as <code><loc href="#element-unique">unique</loc></code>. The key element
      applies to the <code>number</code> attribute value of
      <code>part</code> elements that are children of the <code>
      parts</code> element. This declaration of <code>
      number</code> as a key means that its value must be unique
      and cannot be set to nil (i.e. is not nillable), and the
      name that is associated with the
      key, <code>pNumKey</code>, makes the key referenceable from
      elsewhere.
    </p>
    <p>
       To ensure that the part-quantity elements have
      corresponding part descriptions, we say that the <code>
      number</code> attribute ( <phrase diff="del"><code>&lt;field&gt;@number&lt;/field&gt;</code></phrase>
      <phrase diff="add"><code>&lt;field xpath="@number"/&gt;</code></phrase>) of those
      elements
      (<phrase diff="del"><code>&lt;selector&gt;zip/part&lt;/selector&gt;</code></phrase>
      <phrase diff="add"><code>&lt;selector xpath="r:regions/r:zip/r:part"/&gt;</code></phrase>)
      must reference the <code>pNumKey</code> key. This
      declaration of <code>number</code> as a <code>keyref</code> does not
      mean that its value must be unique, but it does mean there
      must exist a <code>pNumKey</code> with the same value.
    </p>
    <p>
       As you may have figured out by analogy with <code><loc href="#element-unique">unique</loc></code>, it is possible to
      define combinations of <code><loc href="#element-key">
      key</loc></code> and <code><loc href="#element-keyref">
      keyref</loc></code> values. Using this mechanism, we could go
      beyond simply requiring the product numbers to be equal,
      and define a combination of values that must be equal. Such
      values may involve combinations of multiple value types
      (<code><loc href="#string">string</loc></code>, <code> <loc href="#integer">integer</loc></code>, <code><loc href="#date">
      date</loc></code>, etc.), provided that the order and type of
      the <code><loc href="#element-field">field</loc></code> element
      references is the same in both the <code><loc href="#element-key">key</loc></code> and <code><loc href="#element-keyref">keyref</loc></code> definitions.
    </p>
    </div2>
    <div2 id="schemaConstraintsVsXML1"><head>XML Schema Constraints vs. XML 1.0 ID Attributes</head>
    <p>
       <xspecref href="http://www.w3.org/TR/2000/REC-xml-20001006">XML 1.0</xspecref>
      provides a mechanism for ensuring uniqueness using
      the ID attribute and its associated attributes IDREF and
      IDREFS. This mechanism is also provided in XML Schema
      through the <code><loc href="#ID">ID</loc></code>, <code><loc href="#IDREF">IDREF</loc></code>, and <code> <loc href="#IDREFS">IDREFS</loc></code> simple types which can be used
      for declaring XML 1.0-style attributes. XML Schema also
      introduces new mechanisms that are more flexible and
      powerful. For example, XML Schema's mechanisms can be
      applied to any element and attribute content, regardless of
      its type. In contrast, ID is a type of <emph>attribute</emph>
      and so it cannot be applied to attributes, elements or
      their content. Furthermore, Schema enables you to specify
      the scope within which uniqueness applies whereas the scope
      of an ID is fixed to be the whole document. Finally, Schema
      enables you to create <code><loc href="#element-key">
      key</loc></code>s or a <code> <loc href="#element-keyref">
      keyref</loc></code> from combinations of element and
      attribute content whereas ID has no such facility.
    </p>
    </div2>
    <div2 id="import"><head>Importing Types</head>
    <p id="ref41">The report schema, <code><loc href="#report.xsd">report.xsd</loc></code>, makes use of the
      simple type <code>xipo:SKU</code> that is defined in
      another schema, and in another target
      namespace. Recall that we used <code><loc href="#element-include">include</loc></code> so that the schema in
      <code><loc href="#ipo.xsd">ipo.xsd</loc></code> could make use
      of definitions and declarations from <code><loc href="#address.xsd">address.xsd</loc></code>. We cannot use <code>
      <loc href="#element-include">include</loc></code> here because
      it can only pull in definitions and declarations from a
      schema whose target namespace is the same as the including
      schema's target namespace. Hence, the <code><loc href="#element-include">include</loc></code> element does not
      identify a namespace (although it does require a <code><loc href="#attribute-schemaLocation">
      schemaLocation</loc></code>). The import mechanism that we
      describe in this section is an important mechanism that
      enables schema components from different target namespaces
      to be used together, and hence enables the schema
      validation of instance content defined across multiple
      namespaces.
    </p>
    <p id="ref31">To import the type <code>SKU</code>
      and use it in the report schema, we identify the namespace
      in which <code>SKU</code> is defined, and associate that
      namespace with a prefix for use in the report schema.
      Concretely, we use the <code><loc href="#element-import">
      import</loc></code> element to identify <code>SKU</code>'s
      target namespace, <code>http://www.example.com/IPO</code>,
      and we associate the namespace with the prefix <code>
      xipo</code> using a standard namespace declaration. The
      simple type <code> SKU</code>, defined in the namespace
      <code> http://www.example.com/IPO</code>, may then be
      referenced as <code>xipo:SKU</code> in any of the report
      schema's definitions and declarations.
    </p>
    <p>
       In our example, we imported one simple type from one
      external namespace, and used it for declaring attributes.
      XML Schema in fact permits multiple schema components to be
      imported, from multiple namespaces, and they can be
      referred to in both definitions and declarations. For
      example in <code><loc href="#report.xsd">
      report.xsd</loc></code> we could additionally reuse the
      <code>comment</code> element declared in <code> <loc href="#ipo.xsd">ipo.xsd</loc></code> by referencing that element
      in a declaration:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;element ref="xipo:comment"/&gt;
</eg>
</note>
    <p>
       Note however, that we cannot reuse the <code>shipTo</code>
      element from <code diff="del"><loc href="#po.xsd">po.xsd</loc></code><code diff="add"><loc href="#ipo.xsd">ipo.xsd</loc></code>, and
      the following is not legal because only <emph>global</emph> schema
      components can be imported:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;element ref="xipo:shipTo"/&gt;
</eg>
</note>
    <p>
       In <code><loc href="#ipo.xsd">ipo.xsd</loc></code>, <code>
      comment</code> is declared as a global element, in other
      words it is declared as an element of the <code><loc href="#element-schema">schema</loc></code>. In contrast, <code>
      shipTo</code> is declared locally, in other words it is an
      element declared inside a complex type definition,
      specifically the <code> PurchaseOrderType</code> type.
    </p>
    <p>
       Complex types can also be imported, and they can be used
      as the base types for deriving new types. Only named
      complex types can be imported; local, anonymously defined
      types cannot. Suppose we want to include in our reports the
      name of an analyst, along with contact information. We can
      reuse the (globally defined) complex type <code>
      USAddress</code> from <code> <loc href="#address.xsd">
      address.xsd</loc></code>, and extend it to define a new type
      called <code>Analyst</code><phrase diff="add"> in the report
      schema</phrase> by adding the new elements
      <code> phone</code> and <code>email</code>:
    </p>
<note id="DefiningAnalystByExtending" role="example"><p>Defining Analyst by Extending USAddress</p>
<eg xml:space="preserve">
&lt;complexType name="Analyst"&gt;
 &lt;complexContent&gt;
  &lt;extension base="xipo:USAddress"&gt;
   &lt;sequence&gt;
    &lt;element name="phone" type="string"/&gt;
    &lt;element name="email" type="string"/&gt;
   &lt;/sequence&gt;
  &lt;/extension&gt;
 &lt;/complexContent&gt;
&lt;/complexType&gt;
</eg>
</note>
    <p>
       Using this new type we declare an element called <code>
      analyst</code> as part of the <code>purchaseReport</code>
      element declaration (declarations not shown) in the report
      schema. Then, the following instance document would conform
      to the modified report schema:
    </p>
<note id="InstanceWithAnalyst" role="example"><p>Instance Document Conforming to Report Schema with
            Analyst Type</p>
<eg xml:space="preserve">
&lt;<phrase diff="add">r:</phrase>purchaseReport
  xmlns<phrase diff="add">:r</phrase>="http://www.example.com/Report"
  period="P3M" periodEnding="1999-12-31"&gt;
  &lt;!-- regions and parts elements omitted --&gt;
   &lt;<phrase diff="add">r:</phrase>analyst&gt;
        &lt;name&gt;Wendy Uhro&lt;/name&gt;
        &lt;street&gt;10 Corporate Towers&lt;/street&gt;
        &lt;city&gt;San Jose&lt;/city&gt;
        &lt;state&gt;CA&lt;/state&gt;
        &lt;zip&gt;95113&lt;/zip&gt;
        &lt;<phrase diff="add">r:</phrase>phone&gt;408-271-3366&lt;/<phrase diff="add">r:</phrase>phone&gt;
        &lt;<phrase diff="add">r:</phrase>email&gt;uhro@example.com&lt;/<phrase diff="add">r:</phrase>email&gt;
   &lt;/<phrase diff="add">r:</phrase>analyst&gt;
&lt;/<phrase diff="add">r:</phrase>purchaseReport&gt;
</eg>
</note>

   <p diff="add">
      Note that the report now has both qualified and unqualified elements.  This
      is because some of the elements (<code>name</code>, <code>street</code>, <code>city</code>,
      <code>state</code> and <code>zip</code>) are locally declared in <code><loc href="#ipo.xsd">ipo.xsd</loc></code>, whose
      <code>elementFormDefault</code> is <code>unqualified</code> (by default).  The other elements in the
      example are declared in <code><loc href="#report.xsd">report.xsd</loc></code>, whose <code>elementFormDefault</code> is set to <code>qualified</code>.
    </p>
	<p>
       When schema components are imported from multiple
      namespaces, each namespace must be identified with a
      separate <code><loc href="#element-import">import</loc></code>
      element. The <code> <loc href="#element-import">
      import</loc></code> elements themselves must appear as the
      first children of the <code><loc href="#element-schema">
      schema</loc></code> element. Furthermore, each namespace must
      be associated with a prefix, using a standard namespace
      declaration, and that prefix is used to qualify references
      to any schema components belonging to that namespace.
      Finally, <code><loc href="#element-import">import</loc></code>
      elements optionally contain a <code><loc href="#attribute-schemaLocation">schemaLocation</loc></code>
      attribute to help locate resources associated with the
      namespaces. We discuss the <code><loc href="#attribute-schemaLocation">schemaLocation</loc></code>
      attribute in more detail in a later section.
    </p>
    <div3 id="Libs"><head>Type Libraries</head>
    <p>
       As XML schemas become more widespread, schema authors will
      want to create simple and complex types that can be shared
      and used as building blocks for creating new
      schemas. XML Schemas already provides types that play this
      role, in particular, the types described in the <loc href="#SimpleTypeFacets">Simple Types appendix</loc> and in an
      introductory <loc href="http://www.w3.org/2001/03/XMLSchema/TypeLibrary.xsd">
      type library</loc>.
</p>
<p>
     Schema authors will undoubtedly want to create their own
     libraries of types to represent currency, units of measurement,
     business addresses, and so on. Each library might consist of a
     schema containing one or more definitions, for example, a schema
     containing a currency type:
    </p>
<note id="ExampleCurrencyType" role="example"><p>Example Currency Type in Type Library</p>
<eg xml:space="preserve">
&lt;schema targetNamespace="http://www.example.com/Currency"
        xmlns:c="http://www.example.com/Currency"
        xmlns="http://www.w3.org/2001/XMLSchema"&gt;

  &lt;annotation&gt;
    &lt;documentation xml:lang="en"&gt;
      Definition of Currency type based on ISO 4217
    &lt;/documentation&gt;
  &lt;/annotation&gt;

  &lt;complexType name="Currency"&gt;
    &lt;simpleContent&gt;
      &lt;extension base="decimal"&gt;
        &lt;attribute name="name"&gt;
          &lt;simpleType&gt;
            &lt;restriction base="string"&gt;

              &lt;enumeration value="AED"&gt;
                &lt;annotation&gt;
                  &lt;documentation xml:lang="en"&gt;
                    United Arab Emirates: Dirham (1 Dirham = 100 Fils)
                  &lt;/documentation&gt;
                &lt;/annotation&gt;
              &lt;/enumeration&gt;

              &lt;enumeration value="AFA"&gt;
                &lt;annotation&gt;
                  &lt;documentation xml:lang="en"&gt;
                    Afghanistan: Afghani (1 Afghani = 100 Puls)
                  &lt;/documentation&gt;
                &lt;/annotation&gt;
              &lt;/enumeration&gt;

              &lt;enumeration value="ALL"&gt;
                &lt;annotation&gt;
                  &lt;documentation xml:lang="en"&gt;
                    Albania, Lek (1 Lek = 100 Qindarka)
                  &lt;/documentation&gt;
                &lt;/annotation&gt;
              &lt;/enumeration&gt;

              &lt;!-- and other currencies --&gt;

            &lt;/restriction&gt;
          &lt;/simpleType&gt;
        &lt;/attribute&gt;
      &lt;/extension&gt;
    &lt;/simpleContent&gt;
  &lt;/complexType&gt;

&lt;/schema&gt;
</eg>
</note>
    <p>
       An example of an element appearing in an instance and
      having this type:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;convertFrom name="AFA"&gt;199.37&lt;/convertFrom&gt;
</eg>
</note>
    <p>
       Once we have defined the currency type, we can make it
      available for re-use in other schemas through the <code><loc href="#element-import">import</loc></code> mechanism just
      described.
    </p>
    </div3></div2>
    <div2 id="any"><head>Any Element, Any Attribute</head>
    <p>
       In previous sections we have seen several mechanisms for
      extending the content models of complex types. For example,
      a mixed content model can contain arbitrary character data
      in addition to elements, and for example, a content model
      can contain elements whose types are imported
      from external namespaces. However, these mechanisms provide
      very broad and very narrow controls respectively. The
      purpose of this section is to describe a flexible mechanism
      that enables content models to be extended by any elements
      and attributes belonging to specified namespaces.
    </p>
    <p>
       To illustrate, consider a version of the quarterly report,
      <code><loc href="#Q99html.xml">4Q99html.xml</loc></code>, in
      which we have embedded an <phrase diff="add">X</phrase>HTML representation of the XML
      parts data. The <phrase diff="add">X</phrase>HTML content appears as the content of the
      element <code> htmlExample</code>, and the default
      namespace is changed on the outermost <phrase diff="add">X</phrase>HTML element
      (<code>table</code>) so that all the <phrase diff="add">X</phrase>HTML elements belong
      to the <phrase diff="add">X</phrase>HTML namespace, <code>
      http://www.w3.org/1999/xhtml</code>:
    </p>
<note id="Q99html.xml" role="example"><p>Quarterly Report with
            <phrase diff="add">X</phrase>HTML, 4Q99html.xml</p>
<eg xml:space="preserve">
&lt;purchaseReport
  xmlns="http://www.example.com/Report"
  period="P3M" periodEnding="1999-12-31"&gt;

  &lt;regions&gt;
    &lt;!-- part sales listed by zip code, data from 4Q99.xml --&gt;
  &lt;/regions&gt;

  &lt;parts&gt;
    &lt;!-- part descriptions from 4Q99.xml --&gt;
  &lt;/parts&gt;

  &lt;htmlExample&gt;
    &lt;table xmlns="http://www.w3.org/1999/xhtml"
           border="0" width="100%"&gt;
      &lt;tr&gt;
        &lt;th align="left"&gt;Zip Code&lt;/th&gt;
        &lt;th align="left"&gt;Part Number&lt;/th&gt;
        &lt;th align="left"&gt;Quantity&lt;/th&gt;
      &lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;95819&lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt;872-AA&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt;926-AA&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt;833-AA&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt;455-BX&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;63143&lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt;455-BX&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
  &lt;/htmlExample&gt;

&lt;/purchaseReport&gt;
</eg>
</note>
    <p id="ref32">To permit the appearance of <phrase diff="add">X</phrase>HTML in
      the instance document we modify the report schema by
      declaring a new element <code>htmlExample</code> whose
      content is defined by the <code><loc href="#element-any">
      any</loc></code> element. In general, an <code><loc href="#element-any">any</loc></code> element specifies that any
      well-formed XML is permissible in a type's content model.
      In the example, we require the XML to belong to the
      namespace <code> http://www.w3.org/1999/xhtml</code>, in
      other words, it should be <phrase diff="add">X</phrase>HTML. The example also requires
      there to be at least one element present from this
      namespace, as indicated by the values of <code><loc href="#attribute-minOccurs">minOccurs</loc></code> and <code> <loc href="#attribute-maxOccurs">maxOccurs</loc></code>:
    </p>
<note id="ModificationtoPurchaseReport" role="example"><p>Modification to purchaseReport Declaration to Allow
            <phrase diff="add">X</phrase>HTML in Instance</p>
<eg xml:space="preserve">
&lt;element name="purchaseReport"&gt;
  &lt;complexType&gt;
    &lt;sequence&gt;
      &lt;element name="regions" type="r:RegionsType"/&gt;
      &lt;element name="parts"   type="r:PartsType"/&gt;
      &lt;element name="htmlExample"&gt;
        &lt;complexType&gt;
          &lt;sequence&gt;
            &lt;any namespace="http://www.w3.org/1999/xhtml"
                 minOccurs="1" maxOccurs="unbounded"
                 processContents="skip"/&gt;
          &lt;/sequence&gt;
        &lt;/complexType&gt;
      &lt;/element&gt;
    &lt;/sequence&gt;
    &lt;attribute name="period"       type="duration"/&gt;
    &lt;attribute name="periodEnding" type="date"/&gt;
  &lt;/complexType&gt;
&lt;/element&gt;
</eg>
</note>
    <p id="ref33">The modification permits some
      well-formed XML belonging to the namespace <code>
      http://www.w3.org/1999/xhtml</code> to appear inside the
      <code>htmlExample</code> element. Therefore <code><loc href="#Q99html.xml">4Q99html.xml</loc></code> is permissible
      because there is one element which (with its children) is
      well-formed, the element appears inside the appropriate
      element (<code>htmlExample</code>), and the instance
      document asserts that the element and its content belongs
      to the required namespace. However, the <phrase diff="add">X</phrase>HTML may not
      actually be valid because nothing in <code><loc href="#Q99html.xml">4Q99html.xml</loc></code> by itself can
      provide that guarantee. If such a guarantee is required,
      the value of the <code><loc href="#attribute-processContents">processContents</loc></code>
      attribute should be set to <code>strict</code>
      (the default value). In this case, an XML processor is
      obliged to obtain the schema associated with the required
      namespace, and validate the <phrase diff="add">X</phrase>HTML appearing within the
      <code>htmlExample</code> element.
    </p>
    <p id="textType">In another example, we define a <code>text</code>
      type which is
      similar to the text type defined in XML Schema's introductory <loc href="http://www.w3.org/2001/03/XMLSchema/TypeLibrary.xsd">
      type library</loc> (see also <specref ref="Libs"/>), and
      is suitable for internationalized human-readable text. The
      text type allows an unrestricted mixture of character content
      and element content from any namespace, for example <loc href="http://www.w3.org/TR/ruby/">Ruby</loc> annotations, along with
      an optional <code>xml:lang</code> attribute. The <code>lax</code>
      value of the
      <code><loc href="#attribute-processContents">processContents</loc></code>
      attribute instructs an XML processor to validate the element
      content on a can-do basis: It will validate elements and attributes for
      which it can obtain schema information, but it will not signal errors
      for those it cannot obtain any schema information.
    </p>
<note id="TextTypeNote" role="example"><p>Text Type</p>
<eg xml:space="preserve">
&lt;xsd:complexType name="text"&gt;
  &lt;xsd:complexContent mixed="true"&gt;
    &lt;xsd:restriction base="xsd:anyType"&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:attribute ref="xml:lang"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:complexContent&gt;
&lt;/xsd:complexType&gt;
</eg>
</note>
    <p id="ref34">Namespaces may be used to permit and
      forbid element content in various ways depending upon the
      value of the <code><loc href="#attribute-namespace">
      namespace</loc></code> attribute, as shown in <loc href="#nsTable">Table 4</loc>:
    </p>
    <table id="nsTable" border="2" width="100%" summary="namespace attribute in any">
      <tbody>
        <tr>
          <th align="left" colspan="2">Table 4. Namespace Attribute in Any</th>
        </tr>
        <tr>
          <th>Value of Namespace Attribute</th>
          <th>Allowable Element Content</th>
        </tr>
        <tr>
          <td>##any</td>
          <td>Any well-formed XML from any namespace (default)</td>
        </tr>
        <tr>
          <td>##local</td>
          <td>Any well-formed XML that is not qualified, i.e. not
            declared to be in a namespace</td>
        </tr>
        <tr>
          <td>##other</td>
          <td>Any well-formed XML that is <phrase diff="add">from a namespace other
            than</phrase><phrase diff="del">not from</phrase> the target
            namespace of the type being defined <phrase diff="add">(unqualified
            elements are not allowed)</phrase></td>
        </tr>
        <tr>
          <td>"http://www.w3.org/1999/xhtml ##targetNamespace"</td>
          <td>Any well-formed XML belonging to any namespace in the
            (whitespace separated) list; ##targetNamespace is
            shorthand for the target namespace of the type being
            defined</td>
        </tr>
      </tbody>
    </table>
    <p id="ref35">In addition to the <code><loc href="#element-any">any</loc></code> element which enables element
      content according to namespaces, there is a corresponding
      <code><loc href="#element-anyAttribute">
      anyAttribute</loc></code> element which enables attributes to
      appear in elements. For example, we can permit any <phrase diff="add">X</phrase>HTML
      attribute to appear as part of the <code>htmlExample</code>
      element by adding <code> <loc href="#element-anyAttribute">
      anyAttribute</loc></code> to its declaration:
    </p>
<note id="ModificationToHTMLExample" role="example"><p>Modification to htmlExample Declaration to Allow <phrase diff="add">X</phrase>HTML
            Attributes</p>
<eg xml:space="preserve">
&lt;element name="htmlExample"&gt;
  &lt;complexType&gt;
    &lt;sequence&gt;
      &lt;any namespace="http://www.w3.org/1999/xhtml"
           minOccurs="1" maxOccurs="unbounded"
           processContents="skip"/&gt;
    &lt;/sequence&gt;
    &lt;anyAttribute namespace="http://www.w3.org/1999/xhtml"/&gt;
  &lt;/complexType&gt;
&lt;/element&gt;
</eg>
</note>
    <p>
       This declaration permits an <phrase diff="add">X</phrase>HTML attribute, say <code>
      href</code>, to appear in the <code>htmlExample</code>
      element. For example:
    </p>
<note id="AnXHTMLAttribute" role="example"><p>An <phrase diff="add">X</phrase>HTML attribute in the htmlExample Element</p>
<eg xml:space="preserve">
....
  &lt;htmlExample xmlns:h="http://www.w3.org/1999/xhtml"
               h:href="http://www.example.com/reports/4Q99.html"&gt;
    &lt;!-- <phrase diff="add">X</phrase>HTML markup here --&gt;
  &lt;/htmlExample&gt;
....
</eg>
</note>
    <p>
       The <code><loc href="#attribute-namespace">
      namespace</loc></code> attribute in an <code> <loc href="#element-anyAttribute">anyAttribute</loc></code> element can
      be set to any of the values listed in <loc href="#nsTable">
      Table 4</loc> for the <code> <loc href="#element-any">
      any</loc></code> element, and <code><loc href="#element-anyAttribute">anyAttribute</loc></code> can be
      specified with a <code><loc href="#attribute-processContents">processContents</loc></code>
      attribute. In contrast to an <code><loc href="#element-any">
      any</loc></code> element, <code> <loc href="#element-anyAttribute">anyAttribute</loc></code> cannot
      constrain the number of attributes that may appear in an
      element.
    </p>
    </div2>
    <div2 id="schemaLocation"><head>schemaLocation</head>
    <p>
       XML Schema uses the <code><loc href="#attribute-schemaLocation">schemaLocation</loc></code> and
      <code><loc href="#attribute-xsischemaLocation">
      xsi:schemaLocation</loc></code> attributes in three
      circumstances.
    </p>
    <p id="ref40">1. In an instance document, the
      attribute <code> <loc href="#attribute-xsischemaLocation">
      xsi:schemaLocation</loc></code> provides hints from the
      author to a processor regarding the location of schema
      documents. The author warrants that these schema documents
      are relevant to checking the validity of the document
      content, on a namespace by namespace basis. For example, we
      can indicate the location of the Report schema to a
      processor of the Quarterly Report:
    </p>
<note id="UsingSchemaLocationInQuarterly" role="example"><p>Using schemaLocation in the Quarterly Report,
            4Q99html.xml</p>
<eg xml:space="preserve">
&lt;purchaseReport
  xmlns="http://www.example.com/Report"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.example.com/Report
  http://www.example.com/Report.xsd"
  period="P3M" periodEnding="1999-12-31"&gt;

  &lt;!-- etc. --&gt;

&lt;/purchaseReport&gt;
</eg>
</note>
    <p>
      <phrase diff="del">The <code><loc href="#attribute-schemaLocation">
      schemaLocation</loc></code> attribute contains pairs of
      values: The first member of each pair is the namespace for
      which the second member is the hint describing where to
      find to an appropriate schema document.</phrase>
      <phrase diff="add">The <code><loc href="#attribute-schemaLocation">schemaLocation</loc></code>
      attribute value consists of one or more pairs of URI references,
      separated by white space. The first member of each pair is a namespace
      name, and the second member of the pair is a hint describing where to
      find an appropriate schema document for that namespace.</phrase>
      The presence of
      these hints does not require the processor to obtain or use
      the cited schema documents, and the processor is free to
      use other schemas obtained by any suitable means, or to use
      no schema at all.
    </p>
    <p>
       A schema is not required to have a namespace (see <specref ref="UndeclaredTNS"/>) and so there is a <code>
      <loc href="#attribute-noNamespaceSchemaLocation">
      noNamespaceSchemaLocation</loc></code> attribute which is
      used to provide hints for the locations of schema documents
      that do not have target namespaces.
    </p>
    <p>
       2. In a schema, the <code><loc href="#element-include">
      include</loc></code> element has a required <code><loc href="#attribute-schemaLocation">schemaLocation</loc></code>
      attribute, and it contains a URI reference which must
      identify a schema document. The effect is to compose a
      final effective schema by merging the declarations and
      definitions of the including and the included schemas. For
      example, in <specref ref="IPO"/>, the type
      definitions of <code>Address</code>, <code>
      USAddress</code>, <code>UKAddress</code>, <code>
      USState</code> (along with their attribute and local
      element declarations) from <code><loc href="#address.xsd">
      address.xsd</loc></code> were added to the element
      declarations of <code>purchaseOrder</code> and <code>
      comment</code>, and the type definitions of <code>
      PurchaseOrderType</code>, <code>Items</code> and <code>
      SKU</code> (along with their attribute and local element
      declarations) from <code><loc href="#ipo.xsd">
      ipo.xsd</loc></code> to create a single schema.
    </p>
    <p>
       3. Also in a schema, the <code><loc href="#element-import">
      import</loc></code> element has optional <code><loc href="#attribute-namespace">namespace</loc></code> and <code><loc href="#attribute-schemaLocation">schemaLocation</loc></code>
      attributes. If present, the <code><loc href="#attribute-schemaLocation">schemaLocation</loc></code>
      attribute is understood in a way which parallels the
      interpretation of <code> <loc href="#attribute-xsischemaLocation">
      xsi:schemaLocation</loc></code> in (1). Specifically, it
      provides a hint from the author to a processor regarding
      the location of a schema document that the author warrants
      supplies the required components for the namespace
      identified by the <code><loc href="#attribute-namespace">
      namespace</loc></code> attribute. To import components that
      are not in any target namespace, the <code><loc href="#element-import">import</loc></code> element is used without
      a <code><loc href="#attribute-namespace">namespace</loc></code>
      attribute (and with or without a <code><loc href="#attribute-schemaLocation">schemaLocation</loc></code>
      attribute). References to components imported in this
      manner are unqualified.
    </p>
    <p>
       Note that the <code><loc href="#attribute-schemaLocation">
      schemaLocation</loc></code> is only a hint and some
      processors and applications will have reasons to not use
      it. For example, an <phrase diff="add">X</phrase>HTML editor may have a built-in <phrase diff="add">X</phrase>HTML
      schema.
    </p>
    </div2>
    <div2 id="conformance"><head>Conformance</head>
    <p>
       An instance document may be processed against a schema to
      verify whether the rules specified in the schema are
      honored in the instance. Typically, such processing
      actually does two things, (1) it checks for conformance to
      the rules, a process called schema validation, and (2) it
      adds supplementary information that is not immediately
      present in the instance, such as types and default values,
      called infoset contributions.
    </p>
    <p>
       The author of an instance document, such as a particular
      purchase order, may claim, in the instance itself, that it
      conforms to the rules in a particular schema. The author
      does this using the <code><loc href="#attribute-schemaLocation">schemaLocation</loc></code>
      attribute discussed above. But regardless of whether a
      <code> <loc href="#attribute-schemaLocation">
      schemaLocation</loc></code> attribute is present, an
      application is free to process the document against any
      schema. For example, a purchasing application may have the
      policy of always using a certain purchase order schema,
      regardless of any <code><loc href="#attribute-schemaLocation">schemaLocation</loc></code>
      values.
    </p>
    <p>
       Conformance checking can be thought of as proceeding in
      steps, first checking that the root element of the document
      instance has the right contents, then checking that each
      subelement conforms to its description in a schema, and so
      on until the entire document is verified. Processors are
      required to report what checking has been carried out.
    </p>
    <p>
       To check an element for conformance, the processor first
      locates the declaration for the element in a schema, and
      then checks that the <code><loc href="#attribute-targetNamespace">targetNamespace</loc></code>
      attribute in the schema matches the actual namespace URI of
      the element. Alternatively, it may determine that the schema does not
      have a <code><loc href="#attribute-targetNamespace">
      targetNamespace</loc></code> attribute and the instance
      element is not namespace-qualified.
    </p>
    <p>
       Supposing the namespaces match, the processor then
      examines the type of the element, either as given by the
      declaration in the schema, or by an <code><loc href="#attribute-xsitype">xsi:type</loc></code> attribute in the
      instance. If the latter, the instance type must be an
      allowed substitution for the type given in the schema; what
      is allowed is controlled by the <code> <loc href="#attribute-block">block</loc></code> attribute in the
      element declaration. At this same time, default values and
      other infoset contributions are applied.
    </p>
    <p>
       Next the processor checks the immediate attributes and
      contents of the element, comparing these against the
      attributes and contents permitted by the element's type.
      For example, considering a <code>shipTo</code> element such
      as the one in <specref ref="POSchema"/>, the
      processor checks what is permitted for an <code>
      Address</code>, because that is the <code>shipTo</code>
      element's type.
    </p>
    <p>
       If the element has a simple type, the processor verifies
      that the element has no attributes or contained elements,
      and that its character content matches the rules for the
      simple type. This sometimes involves checking the character
      sequence against regular expressions or enumerations, and
      sometimes it involves checking that the character sequence
      represents a value in a permitted range.
    </p>
    <p>
       If the element has a complex type, then the processor
      checks that any required attributes are present and that
      their values conform to the requirements of their simple
      types. It also checks that all required subelements are
      present, and that the sequence of subelements (and any
      mixed text) matches the content model declared for the
      complex type. Regarding subelements, schemas can either
      require exact name matching, permit substitution by an
      equivalent element or permit substitution by any element
      allowed by an 'any' particle.
    </p>
    <p>
       Unless a schema indicates otherwise (as it can for 'any'
      particles) conformance checking then proceeds one level
      more deeply by looking at each subelement in turn,
      repeating the process described above.
    </p>
    </div2></div1>
    </body>
    <back>

<div1 id="Acks">
<head>Acknowledgements</head>

    <p>
       Many people have contributed ideas, material and feedback
      that has improved this document. In particular, the editor
      acknowledges contributions from David Beech,
      Paul Biron, Don Box, Allen Brown, David Cleary, Dan
      Connolly, Roger Costello, Martin D&#xFC;rst, Martin Gudgin, Dave Hollander,
      Joe Kesselman, John McCarthy, Andrew Layman, Eve Maler,
      Ashok Malhotra, Noah Mendelsohn, Michael Sperberg-McQueen,
      Henry Thompson, Misha Wolf, and Priscilla Walmsley for
      validating the examples.
    </p>

<p diff="add">At the time the first edition of this
specification was published, the members of the XML Schema Working Group 
were:</p>
<orglist diff="add">
<member>
 <name>Jim Barnette</name>
 <affiliation>Defense Information Systems Agency (DISA)</affiliation>
</member>
<member>
 <name>Paul V. Biron</name>
 <affiliation>Health Level Seven</affiliation>
</member>
<member>
 <name>Don Box</name>
 <affiliation>DevelopMentor</affiliation>
</member>
<member>
 <name>Allen Brown</name>
 <affiliation>Microsoft</affiliation>
</member>
<member>
 <name>Lee Buck</name>
 <affiliation>TIBCO Extensibility</affiliation>
</member>
<member>
 <name>Charles E. Campbell</name>
 <affiliation>Informix</affiliation>
</member>
 <member>
  <name>Wayne Carr</name>
  <affiliation>Intel</affiliation>
 </member>
<member>
 <name>Peter Chen</name>
 <affiliation>Bootstrap Alliance and LSU</affiliation>
</member>
<member>
 <name>David Cleary</name>
 <affiliation>Progress Software</affiliation>
</member>
<member>
 <name>Dan Connolly</name>
 <affiliation>W3C</affiliation>
 <role>staff contact</role>
</member>
<member>
 <name>Ugo Corda</name>
 <affiliation>Xerox</affiliation>
</member>
<member>
 <name>Roger L. Costello</name>
 <affiliation>MITRE</affiliation>
</member>
 <member>
  <name>Haavard Danielson</name>
  <affiliation>Progress Software</affiliation>
 </member>
 <member>
  <name>Josef Dietl</name>
  <affiliation>Mozquito Technologies</affiliation>
 </member>
<member>
 <name>David Ezell</name>
 <affiliation>Hewlett-Packard Company
 </affiliation>
</member>
 <member>
  <name>Alexander Falk</name>
  <affiliation>Altova GmbH</affiliation>
 </member>
<member>
 <name>David Fallside</name>
 <affiliation>IBM</affiliation>
</member>
 <member>
  <name>Dan Fox</name>
  <affiliation>Defense Logistics Information Service (DLIS)</affiliation>
 </member>
<member>
 <name>Matthew Fuchs</name>
 <affiliation>Commerce One</affiliation>
</member>
<member>
 <name>Andrew Goodchild</name>
 <affiliation>Distributed Systems Technology Centre (DSTC Pty Ltd)</affiliation>
</member>
<member>
 <name>Paul Grosso</name>
 <affiliation>Arbortext, Inc</affiliation>
</member>
<member>
 <name>Martin Gudgin</name>
 <affiliation>DevelopMentor</affiliation>
</member>
<member>
 <name>Dave Hollander</name>
 <affiliation>Contivo, Inc</affiliation>
 <role>co-chair</role>
</member>
<member>
 <name>Mary Holstege</name>
 <affiliation>Invited Expert</affiliation>
</member>
<member>
 <name>Jane Hunter</name>
 <affiliation>Distributed Systems Technology Centre (DSTC Pty Ltd)</affiliation>
</member>
 <member>
  <name>Rick Jelliffe</name>
  <affiliation>Academia Sinica</affiliation>
 </member>
 <member>
  <name>Simon Johnston</name>
  <affiliation>Rational Software</affiliation>
 </member>
 <member>
  <name>Bob Lojek</name>
  <affiliation>Mozquito Technologies</affiliation>
 </member>
<member>
 <name>Ashok Malhotra</name>
 <affiliation>Microsoft</affiliation>
</member>
 <member>
  <name>Lisa Martin</name>
  <affiliation>IBM</affiliation>
 </member>
<member>
 <name>Noah Mendelsohn</name>
 <affiliation>Lotus Development Corporation</affiliation>
</member>
 <member>
  <name>Adrian Michel</name>
  <affiliation>Commerce One</affiliation>
 </member>
 <member>
  <name>Alex Milowski</name>
  <affiliation>Invited Expert</affiliation>
 </member>
<member>
 <name>Don Mullen</name>
 <affiliation>TIBCO Extensibility</affiliation>
</member>
 <member>
  <name>Dave Peterson</name>
  <affiliation>Graphic Communications Association</affiliation>
 </member>
<member>
 <name>Jonathan Robie</name>
 <affiliation>Software AG</affiliation>
</member>
<member>
 <name>Eric Sedlar</name>
 <affiliation>Oracle Corp.</affiliation>
</member>
<member>
 <name>C. M. Sperberg-McQueen</name>
 <affiliation>W3C</affiliation>
 <role>co-chair</role>
</member>
<member>
 <name>Bob Streich</name>
 <affiliation>Calico Commerce</affiliation>
</member>
 <member>
  <name>William K. Stumbo</name>
  <affiliation>Xerox</affiliation>
 </member>
<member>
 <name>Henry S. Thompson</name>
 <affiliation>University of Edinburgh</affiliation>
</member>
<member>
 <name>Mark Tucker</name>
 <affiliation>Health Level Seven</affiliation>
</member>
 <member>
  <name>Asir S. Vedamuthu</name>
  <affiliation>webMethods, Inc</affiliation>
 </member>
<member>
 <name>Priscilla Walmsley</name>
 <affiliation>XMLSolutions</affiliation>
</member>
<member>
 <name>Norm Walsh</name>
 <affiliation>Sun Microsystems</affiliation>
</member>
<member>
 <name>Aki Yoshida</name>
 <affiliation>SAP AG</affiliation>
</member>
 <member>
 <name>Kongyi Zhou</name>
 <affiliation>Oracle Corp.</affiliation>
</member>
</orglist>
 <p diff="add">The XML Schema Working Group has benefited in its work from the
participation and contributions of a number of people not currently
members of the Working Group, including
in particular those named below.  Affiliations given are those current at
the time of their work with the WG.
</p>
 <orglist diff="add">
<member>
 <name>Paula Angerstein</name>
 <affiliation>Vignette Corporation</affiliation>
</member>
<member>
 <name>David Beech</name>
 <affiliation>Oracle Corp.</affiliation>
</member>
 <member>
  <name>Gabe Beged-Dov</name>
  <affiliation>Rogue Wave Software</affiliation>
 </member>
<member>
 <name>Greg Bumgardner</name>
 <affiliation>Rogue Wave Software</affiliation>
</member>
<member>
 <name>Dean Burson</name>
 <affiliation>Lotus Development Corporation</affiliation>
</member>
 <member>
  <name>Mike Cokus</name>
  <affiliation>MITRE</affiliation>
 </member>
 <member>
 <name>Andrew Eisenberg</name>
 <affiliation>Progress Software</affiliation>
</member>
<member>
 <name>Rob Ellman</name>
 <affiliation>Calico Commerce</affiliation>
</member>
 <member>
  <name>George Feinberg</name>
  <affiliation>Object Design</affiliation>
 </member>
 <member>
  <name>Charles Frankston</name>
  <affiliation>Microsoft</affiliation>
 </member>
 <member>
  <name>Ernesto Guerrieri</name>
  <affiliation>Inso</affiliation>
 </member>
 <member>
  <name>Michael Hyman</name>
  <affiliation>Microsoft</affiliation>
 </member>
<member>
 <name>Renato Iannella</name>
 <affiliation>Distributed Systems Technology Centre (DSTC Pty Ltd)</affiliation>
</member>
 <member>
  <name>Dianne Kennedy</name>
  <affiliation>Graphic Communications Association</affiliation>
 </member>
<member>
 <name>Janet Koenig</name>
 <affiliation>Sun Microsystems</affiliation>
</member>
<member>
 <name>Setrag Khoshafian</name>
 <affiliation>Technology Deployment International (TDI)</affiliation>
</member>
<member>
 <name>Ara Kullukian</name>
 <affiliation>Technology Deployment International (TDI)</affiliation>
</member>
 <member>
 <name>Andrew Layman</name>
 <affiliation>Microsoft</affiliation>
</member>
<member>
 <name>Dmitry Lenkov</name>
 <affiliation>Hewlett-Packard Company</affiliation>
</member>
<member>
 <name>John McCarthy</name>
 <affiliation>Lawrence Berkeley National Laboratory</affiliation>
</member>
<member>
 <name>Murata Makoto</name>
 <affiliation>Xerox</affiliation>
</member>
<member>
 <name>Eve Maler</name>
 <affiliation>Sun Microsystems</affiliation>
</member>
<member>
 <name>Murray Maloney</name>
 <affiliation>Muzmo Communication, acting for Commerce One</affiliation>
</member>
 <member>
  <name>Chris Olds</name>
  <affiliation>Wall Data</affiliation>
 </member>
<member>
 <name>Frank Olken</name>
 <affiliation>Lawrence Berkeley National Laboratory</affiliation>
</member>
<member>
 <name>Shriram Revankar</name>
 <affiliation>Xerox</affiliation>
</member>
<member>
 <name>Mark Reinhold</name>
 <affiliation>Sun Microsystems</affiliation>
</member>
<member>
 <name>John C. Schneider</name>
 <affiliation>MITRE</affiliation>
</member>
 <member>
  <name>Lew Shannon</name>
  <affiliation>NCR</affiliation>
 </member>
 <member>
  <name>William Shea</name>
  <affiliation>Merrill Lynch</affiliation>
 </member>
 <member>
  <name>Ralph Swick</name>
  <affiliation>W3C</affiliation>
 </member>
 <member>
  <name>Tony Stewart</name>
  <affiliation>Rivcom</affiliation>
 </member>
<member>
 <name>Matt Timmermans</name>
 <affiliation>Microstar</affiliation>
</member>
  <member>
 <name>Jim Trezzo</name>
 <affiliation>Oracle Corp.</affiliation>
</member>
<member>
 <name>Steph Tryphonas</name>
 <affiliation>Microstar</affiliation>
</member>
 </orglist>
<p diff="add">The lists given above pertain to the first edition.
At the time work on this second edition was completed,
the membership of the Working Group was:</p>
<orglist diff="add">
  <member>
   <name>Leonid Arbouzov</name>
   <affiliation>Sun Microsystems</affiliation>
  </member>
<member>
 <name>Jim Barnette</name>
 <affiliation>Defense Information Systems Agency (DISA)</affiliation>
</member>
<member>
 <name>Paul V. Biron</name>
 <affiliation>Health Level Seven</affiliation>
</member>
<member>
 <name>Allen Brown</name>
 <affiliation>Microsoft</affiliation>
</member>
<member>
 <name>Charles E. Campbell</name>
 <affiliation>Invited expert</affiliation>
</member>
<member>
 <name>Peter Chen</name>
 <affiliation>Invited expert</affiliation>
</member>
  <member>
   <name>Tony Cincotta</name>
   <affiliation>NIST</affiliation>
  </member>
<member>
 <name>David Ezell</name>
 <affiliation>National Association of Convenience Stores</affiliation>
</member>
<member>
 <name>Matthew Fuchs</name>
 <affiliation>Invited expert</affiliation>
</member>
  <member>
   <name>Sandy Gao</name>
   <affiliation>IBM</affiliation>
  </member>
<member>
 <name>Andrew Goodchild</name>
 <affiliation>Distributed Systems Technology Centre (DSTC Pty Ltd)</affiliation>
</member>
 <member>
  <name>Xan Gregg</name>
  <affiliation>Invited expert</affiliation>
 </member>
<member>
 <name>Mary Holstege</name>
 <affiliation>Mark Logic</affiliation>
</member>
   <member>
  <name>Mario Jeckle</name>
  <affiliation>DaimlerChrysler</affiliation>
 </member>
  <member>
   <name>Marcel Jemio</name>
   <affiliation>Data Interchange Standards Association</affiliation>
  </member>
 <member>
  <name>Kohsuke Kawaguchi</name>
  <affiliation>Sun Microsystems</affiliation>
 </member>
<member>
 <name>Ashok Malhotra</name>
 <affiliation>Invited expert</affiliation>
</member>
 <member>
  <name>Lisa Martin</name>
  <affiliation>IBM</affiliation>
 </member>
 <member>
  <name>Jim Melton</name>
  <affiliation>Oracle Corp</affiliation>
 </member>
<member>
 <name>Noah Mendelsohn</name>
 <affiliation>IBM</affiliation>
</member>
 <member>
  <name>Dave Peterson</name>
  <affiliation>Invited expert</affiliation>
 </member>
 <member>
  <name>Anli Shundi</name>
  <affiliation>TIBCO Extensibility</affiliation>
 </member>
<member>
 <name>C. M. Sperberg-McQueen</name>
 <affiliation>W3C</affiliation>
 <role>co-chair</role>
</member>
  <member>
 <name>Hoylen Sue</name>
 <affiliation>Distributed Systems Technology Centre (DSTC Pty Ltd)</affiliation>
</member>
<member>
 <name>Henry S. Thompson</name>
 <affiliation>University of Edinburgh</affiliation>
</member>
 <member>
  <name>Asir S. Vedamuthu</name>
  <affiliation>webMethods, Inc</affiliation>
 </member>
<member>
 <name>Priscilla Walmsley</name>
 <affiliation>Invited expert</affiliation>
</member>
 <member>
 <name>Kongyi Zhou</name>
 <affiliation>Oracle Corp.</affiliation>
</member>
</orglist>
 <p diff="add">
We note with sadness the accidental death of Mario Jeckle
shortly after the completion of work on this document.  
In addition to those named above, several
people served on the Working Group during the development
of this second edition:
<!--* Furthermore, those listed below were members of the working
group at some point during the development of this second edition, but had left
by the time of publication.  In particular we note with sadness the accidental
death of Mario Jeckle shortly before publication. *--></p>
<orglist diff="add">
<member>
<name>Oriol Carbo</name><affiliation>University of Edinburgh</affiliation>
</member>
<member>
<name>Tyng-Ruey Chuang</name><affiliation>Academia Sinica</affiliation>
</member>
<member>
<name>Joey Coyle</name><affiliation>Health Level 7</affiliation>
</member>
<member>
<name>Tim Ewald</name><affiliation>DevelopMentor</affiliation>
</member>
<!--* 
<member>
 <name>Martin Gudgin</name>
 <affiliation>Invited expert</affiliation>
</member>
<member>
 <name>Dave Hollander</name>
 <affiliation>Contivo, Inc</affiliation>
 <role>co-chair</role>
</member>
*-->
  <member>
  <name>Nelson Hung</name>
  <affiliation>Corel</affiliation>
 </member>
 <member>
  <name>Melanie Kudela</name>
  <affiliation>Uniform Code Council</affiliation>
 </member>
<member>
<name>Matthew MacKenzie</name><affiliation>XML Global</affiliation>
</member>
<member>
<name>Cliff Schmidt</name><affiliation>Microsoft</affiliation>
</member>
<member>
<name>John Stanton</name><affiliation>Defense Information Systems Agency</affiliation>
</member>
 <member>
  <name>John Tebbutt</name>
  <affiliation>NIST</affiliation>
 </member>
  <member>
  <name>Ross Thompson</name>
  <affiliation>Contivo</affiliation>
 </member>
<member>
<name>Scott Vorthmann</name><affiliation>TIBCO Extensibility</affiliation>
</member>
 </orglist>
</div1>

    <div1 id="SimpleTypeFacets"><head>Simple Types &amp; their Facets</head>
    <p>
       The legal values for each simple type can be constrained
      through the application of one or more facets. Tables <loc href="#facetsTable1">B1.a</loc>
      and <loc href="#facetsTable2">B1.b</loc> list all of XML Schema's built-in simple types
      and the facets applicable to each type. The names of the
      simple types and the facets are linked from the tables to
      the corresponding descriptions in <xspecref href="&part2;">XML
      Schema Part 2: Datatypes</xspecref>.
    </p>
    <table id="facetsTable1" border="2" width="100%" summary="simple types and their facets">
      <tbody>
        <tr>
          <th align="left" colspan="7">Table B1.a. Simple Types &amp; Applicable Facets</th>
        </tr>
        <tr>
          <th>Simple Types</th>
          <th colspan="6">Facets</th>
        </tr>
        <tr>
          <th></th>
          <th><xspecref href="&part2;#rf-length">length</xspecref></th>
          <th><xspecref href="&part2;#rf-minLength">minLength</xspecref></th>
          <th><xspecref href="&part2;#rf-maxLength">maxLength</xspecref></th>
          <th><xspecref href="&part2;#rf-pattern">pattern</xspecref></th>
          <th><xspecref href="&part2;#rf-enumeration">enumeration</xspecref></th>
          <th><xspecref href="&part2;#rf-whiteSpace">whiteSpace</xspecref></th>
        </tr>
        <tr>
          <td><xspecref href="&part2;#string">string</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#normalizedString">normalizedString</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#token">token</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#base64Binary">base64Binary</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#hexBinary">hexBinary</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#integer">integer</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#positiveInteger">positiveInteger</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#negativeInteger">negativeInteger</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#nonNegativeInteger">nonNegativeInteger</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#nonPositiveInteger">nonPositiveInteger</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#long">long</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#unsignedLong">unsignedLong</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#int">int</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#unsignedInt">unsignedInt</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#short">short</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#unsignedShort">unsignedShort</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#byte">byte</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#unsignedByte">unsignedByte</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#decimal">decimal</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#float">float</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#double">double</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#boolean">boolean</xspecref></td>
          <td></td>
          <td></td>
          <td></td>
          <td align="center">y</td>
          <td></td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#duration">duration</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#dateTime">dateTime</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#date">date</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#time">time</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#gYear">gYear</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#gYearMonth">gYearMonth</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#gMonth">gMonth</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#gMonthDay">gMonthDay</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#gDay">gDay</xspecref></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center"></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#Name">Name</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#QName">QName</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#NCName">NCName</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#anyURI">anyURI</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#language">language</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#ID">ID</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#IDREF">IDREF</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#IDREFS">IDREFS</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="add">y</phrase></td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#ENTITY">ENTITY</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#ENTITIES">ENTITIES</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="add">y</phrase></td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#NOTATION">NOTATION</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#NMTOKEN">NMTOKEN</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#NMTOKENS">NMTOKENS</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="add">y</phrase></td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td colspan="7"><phrase diff="add">Note: (1) Although the <code>whiteSpace</code> facet is
            applicable to this type, the only value that can be specified is <code>collapse</code>.</phrase></td>
        </tr>
      </tbody>
    </table>
    <p>
       The facets listed in Table B1.b apply only to simple types
      which are ordered. Not all simple types are ordered and so
      B1.b does not list all of the simple types.
    </p>
    <table id="facetsTable2" border="2" width="100%" summary="ordered simple types and their facets">
      <tbody>
        <tr>
          <th align="left" colspan="9">Table B1.b. Simple Types &amp; Applicable Facets</th>
        </tr>
        <tr>
          <th>Simple Types</th>
          <th colspan="8">Facets</th>
        </tr>
        <tr>
          <th></th>
          <th>
            <table border="0"><tbody>
              <tr><th align="center"><xspecref href="&part2;#rf-maxInclusive">max</xspecref></th></tr>
              <tr><th align="center"><xspecref href="&part2;#rf-maxInclusive">Inclusive</xspecref></th></tr>
            </tbody></table>
          </th>
          <th>
            <table border="0"><tbody>
              <tr><th align="center"><xspecref href="&part2;#rf-maxExclusive">max</xspecref></th></tr>
              <tr><th align="center"><xspecref href="&part2;#rf-maxExclusive">Exclusive</xspecref></th></tr>
            </tbody></table>
          </th>
          <th>
            <table border="0"><tbody>
              <tr><th align="center"><xspecref href="&part2;#rf-minInclusive">min</xspecref></th></tr>
              <tr><th align="center"><xspecref href="&part2;#rf-minInclusive">Inclusive</xspecref></th></tr>
            </tbody></table>
          </th>
          <th>
            <table border="0"><tbody>
              <tr><th align="center"><xspecref href="&part2;#rf-minExclusive">min</xspecref></th></tr>
              <tr><th align="center"><xspecref href="&part2;#rf-minExclusive">Exclusive</xspecref></th></tr>
            </tbody></table>
          </th>
          <th>
            <table border="0"><tbody>
              <tr><th align="center"><xspecref href="&part2;#rf-totalDigits">total</xspecref></th></tr>
              <tr><th align="center"><xspecref href="&part2;#rf-totalDigits">Digits</xspecref></th></tr>
            </tbody></table>
          </th>
          <th>
            <table border="0"><tbody>
              <tr><th align="center"><xspecref href="&part2;#rf-fractionDigits">fraction</xspecref></th></tr>
              <tr><th align="center"><xspecref href="&part2;#rf-fractionDigits">Digits</xspecref></th></tr>
            </tbody></table>
          </th>
        </tr>
        <tr>
          <td><xspecref href="&part2;#integer">integer</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#positiveInteger">positiveInteger</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#negativeInteger">negativeInteger</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#nonNegativeInteger">nonNegativeInteger</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#nonPositiveInteger">nonPositiveInteger</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#long">long</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#unsignedLong">unsignedLong</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#int">int</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#unsignedInt">unsignedInt</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#short">short</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#unsignedShort">unsignedShort</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#byte">byte</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#unsignedByte">unsignedByte</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"><phrase diff="del">y</phrase><phrase diff="add">see (1)</phrase></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#decimal">decimal</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#float">float</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"></td>
          <td align="center"></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#double">double</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"></td>
          <td align="center"></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#duration">duration</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"></td>
          <td align="center"></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#dateTime">dateTime</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"></td>
          <td align="center"></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#date">date</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"></td>
          <td align="center"></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#time">time</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"></td>
          <td align="center"></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#gYear">gYear</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"></td>
          <td align="center"></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#gYearMonth">gYearMonth</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"></td>
          <td align="center"></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#gMonth">gMonth</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"></td>
          <td align="center"></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#gMonthDay">gMonthDay</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"></td>
          <td align="center"></td>
        </tr>
        <tr>
          <td><xspecref href="&part2;#gDay">gDay</xspecref></td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center">y</td>
          <td align="center"></td>
          <td align="center"></td>
        </tr>
        <tr>
          <td colspan="7">
            <phrase diff="add">Note: (1) Although the <code>fractionDigits</code> facet is
            applicable to this type, the only value that can be specified is zero.</phrase></td>
        </tr>
      </tbody>
    </table>
    </div1><div1 id="usingEntities"><head>Using Entities</head>
    <p>
       XML 1.0 provides various types of entities which are named
      fragments of content that can be used in the construction
      of both DTD's (parameter entities) and instance documents.
      In <specref ref="groups"/>, we noted how named
      groups mimic parameter entities. In this section we show
      how entities can be declared in instance documents, and how
      the functional equivalents of entities can be declared in
      schemas.
    </p>
    <p>
       Suppose we want to declare and use an entity in an
      instance document, and that document is also constrained by
      a schema. For example:
    </p>
<note id="DeclaringAndReferencingAnEntity" role="example"><p>Declaring and referencing an entity in an instance
            document.</p>
<eg xml:space="preserve">
&lt;?xml version="1.0" ?&gt;
&lt;!DOCTYPE <phrase diff="add">p</phrase><phrase diff="del">P</phrase>urchaseOrder [
&lt;!ENTITY eacute "<phrase diff="del">&#xE9;</phrase><phrase diff="add">&amp;#xE9;</phrase>"&gt;
]&gt;
&lt;purchaseOrder xmlns="http://www.example.com/PO1"
               orderDate="1999-10-20<phrase diff="add">"</phrase>&gt;
  &lt;!-- etc. --&gt;
    &lt;city&gt;Montr&amp;eacute;al&lt;/city&gt;
  &lt;!-- etc. --&gt;
&lt;/purchaseOrder&gt;
</eg>
</note>
    <p>
       Here, we declare an entity called <code>eacute</code> as
      part of an internal (DTD) subset, and we reference this
      entity in the content of the <code>city</code> element.
      Note that when this instance document is processed, the
      entity will be <phrase diff="del">dereferenced</phrase>
      <phrase diff="add">resolved</phrase>
      before schema validation takes
      place. In other words, a schema processor will determine
      the validity of the <code>city</code> element using <code>
      Montr&#xE9;al</code> as the element's value.
    </p>
    <p>
       We can achieve a similar but not identical outcome by
      declaring an element in a schema, and by setting the
      element's content appropriately:
    </p>
<note role="example">
<eg xml:space="preserve">
&lt;xsd:element name="eacute" type="xsd:token" fixed="<phrase diff="del">&#xE9;</phrase><phrase diff="add">&amp;#xE9;</phrase>"/&gt;
</eg>
</note>
    <p>
       And this element can be used in an instance document:
    </p>
<note id="UsingAnElementInsteadOfAnEntity" role="example"><p>Using an element instead of an entity in an instance
            document.</p>
<eg xml:space="preserve">
&lt;?xml version="1.0" ?&gt;
&lt;purchaseOrder xmlns="http://www.example.com/PO1"
               xmlns:c="http://www.example.com/characterElements"
               orderDate="1999-10-20<phrase diff="add">"</phrase>&gt;
  &lt;!-- etc. --&gt;
    &lt;city&gt;Montr&lt;c:eacute/&gt;al&lt;/city&gt;
  &lt;!-- etc. --&gt;
&lt;/purchaseOrder&gt;
</eg>
</note>

    <p>
       In this case, a schema processor will process two
      elements, a <code>city</code> element, and an <code>
      eacute</code> element for the contents of which the
      processor will supply the single character <code>
      &#xE9;</code>. Note that the extra element will
      complicate string matching; the two forms of the name
      "Montr&#xE9;al" given in the two examples above will not
      match each other using normal string-comparison techniques.
    </p>
    </div1><div1 id="regexAppendix"><head>Regular Expressions</head>
    <p>
       XML Schema's <code><loc href="#element-pattern">
      pattern</loc></code> facet uses a regular expression language
      that supports <xspecref href="&part2;#UnicodeDB">
       Unicode</xspecref>. It is fully described in <xspecref href="&part2;#regexs">
      XML Schema Part 2</xspecref>. The language is similar to the
      regular expression language used in the <loc href="http://www.perldoc.com/perl5.6/pod/perlre.html"> Perl
      Programming language</loc>, although expressions are matched
      against entire lexical representations rather than
      user-scoped lexical representations such as line and
      paragraph. For this reason, the expression language does
      not contain the metacharacters ^ and $, although ^ is used
      to express exception, e.g. [^0-9]x.
    </p>
    <table id="regexTable" border="2" width="100%" summary="regex examples">
      <tbody>
        <tr>
          <th align="left" colspan="2">Table D1. Examples of Regular Expressions</th>
        </tr>
        <tr>
          <td>Expression</td>
          <td>Match(es)</td>
        </tr>
        <tr>
          <td>Chapter \d</td>
          <td>Chapter 0, Chapter 1, Chapter 2 ....</td>
        </tr>
        <tr>
          <td>Chapter\s\d</td>
          <td>Chapter followed by a single whitespace character
            (space, tab, newline, etc.), followed by a single
            digit</td>
        </tr>
        <tr>
          <td>Chapter\s\w</td>
          <td>Chapter followed by a single whitespace character
            (space, tab, newline, etc.), followed by a word
            character (<loc href="http://www.w3.org/TR/2000/REC-xml-20001006#CharClasses">XML 1.0
            Letter or Digit</loc>)</td>
        </tr>
        <tr>
          <td>Espa<phrase diff="del">n</phrase>&amp;#xF1;ola</td>
          <td>Espa&#xF1;ola</td>
        </tr>
        <tr>
          <td>\p{Lu}</td>
          <td>any uppercase character, the value of \p{} (e.g.
            "Lu") is defined by <xspecref href="&part2;#UnicodeDB">Unicode</xspecref></td>
        </tr>
        <tr>
          <td>\p{IsGreek}</td>
          <td>any Greek character, the 'Is' construction may be
            applied to any block name (e.g. "Greek") as defined
            by <xspecref href="&part2;#UnicodeDB">Unicode</xspecref></td>
        </tr>
        <tr>
          <td>\P{IsGreek}</td>
          <td>any non-Greek character, the 'Is' construction may be
            applied to any block name (e.g. "Greek") as defined
            by <xspecref href="&part2;#UnicodeDB">Unicode</xspecref></td>
        </tr>
        <tr>
          <td>a*x</td>
          <td>x, ax, aax, aaax ....</td>
        </tr>
        <tr>
          <td>a?x</td>
          <td>ax, x</td>
        </tr>
        <tr>
          <td>a+x</td>
          <td>ax, aax, aaax ....</td>
        </tr>
        <tr>
          <td>(a|b)+x</td>
          <td>ax, bx, aax, abx, bax, bbx, aaax, aabx, abax, abbx,
            baax, babx, bbax, bbbx, aaaax ....</td>
        </tr>
        <tr>
          <td>[abcde]x</td>
          <td>ax, bx, cx, dx, ex</td>
        </tr>
        <tr>
          <td>[a-e]x</td>
          <td>ax, bx, cx, dx, ex</td>
        </tr>
        <tr>
          <td>[<phrase diff="add">\</phrase>-ae]x</td>
          <td>-x, ax, ex</td>
        </tr>
        <tr>
          <td>[ae<phrase diff="add">\</phrase>-]x</td>
          <td>ax, ex, -x</td>
        </tr>
        <tr>
          <td>[^0-9]x</td>
          <td>any non-digit character followed by the character x</td>
        </tr>
        <tr>
          <td>\Dx</td>
          <td>any non-digit character followed by the character x</td>
        </tr>
        <tr>
          <td>.x</td>
          <td>any character followed by the character x</td>
        </tr>
        <tr>
          <td>.*abc.*</td>
          <td>1x2abc, abc1x2, z3456abchooray ....</td>
        </tr>
        <tr>
          <td>ab{2}x</td>
          <td>abbx</td>
        </tr>
        <tr>
          <td>ab{2,4}x</td>
          <td>abbx, abbbx, abbbbx</td>
        </tr>
        <tr>
          <td>ab{2,}x</td>
          <td>abbx, abbbx, abbbbx ....</td>
        </tr>
        <tr>
          <td>(ab){2}x</td>
          <td>ababx</td>
        </tr>
      </tbody>
    </table>
    </div1>
    <div1 id="index"><head>Index</head>
    <div2 id="indexEl"><head>XML Schema Elements</head>
    <p>Each element name is <phrase diff="del">linked to
      a formal XML description in either the Structures or
      Datatypes parts of the XML Schema specification. Element
      names are </phrase>followed by one or more links to examples
      (identified by section number) in the Primer<phrase diff="add">
      , plus a link to a formal XML description in either the
      Structures or Datatypes parts of the XML Schema
      specification</phrase>.
    </p>
    <table border="0" cellpadding="3" cellspacing="3">
      <tbody>
        <tr>
          <td id="element-all"><code>all</code>:
          [<specref ref="ref18"/>]
          [<xspecref href="&part1;#element-all">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-annotation"><code>annotation</code>:
          [<specref ref="ref16"/>]
          [<xspecref href="&part1;#element-annotation">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-any"><code>any</code>:
          [<specref ref="ref32"/>]
          [<xspecref href="&part1;#element-any">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-anyAttribute"><code>anyAttribute</code>:
          [<specref ref="ref35"/>]
          [<xspecref href="&part1;#element-anyAttribute">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-appinfo"><phrase diff="add"><code>appinfo</code></phrase><phrase diff="del"><code>appInfo</code></phrase>:
          [<specref ref="ref15"/>]
          [<xspecref href="&part1;#element-appinfo">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-attribute"><code>attribute</code>:
          [<specref ref="ref2"/>]
          [<xspecref href="&part1;#element-attribute">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-attributeGroup"><code>attributeGroup</code>:
          [<specref ref="ref19"/>]
          [<xspecref href="&part1;#element-attributeGroup">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-choice"><code>choice</code>:
          [<specref ref="ref17"/>]
          [<xspecref href="&part1;#element-choice">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-complexContent"><code>complexContent</code>:
          [<specref ref="ref13"/>]
          [<xspecref href="&part1;#element-complexContent">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-complexType"><code>complexType</code>:
          [<specref ref="ref2"/>]
          [<xspecref href="&part1;#element-complexType">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-documentation"><code>documentation</code>:
          [<specref ref="ref14"/>]
          [<xspecref href="&part1;#element-documentation">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-element"><code>element</code>:
          [<specref ref="ref2"/>]
          [<xspecref href="&part1;#element-element">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-enumeration"><code>enumeration</code>:
          [<specref ref="ref10"/>]
          [<xspecref href="&part2;#element-enumeration">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-extension"><code>extension</code>:
          [<specref ref="ref37"/>]
          [<xspecref href="&part1;#element-simpleContent..extension">Structures</xspecref>],
          [<specref ref="ref53"/>]
          [<xspecref href="&part1;#element-complexContent..extension">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-field"><code>field</code>:
          [<specref ref="ref29"/>]
          [<xspecref href="&part1;#element-field">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-group"><code>group</code>:
          [<specref ref="ref17"/>]
          [<xspecref href="&part1;#element-group">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-import"><code>import</code>:
          [<specref ref="ref31"/>]
          [<xspecref href="&part1;#element-import">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-include"><code>include</code>:
          [<specref ref="ref23"/>]
          [<xspecref href="&part1;#element-include">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-key"><code>key</code>:
          [<specref ref="ref30"/>]
          [<xspecref href="&part1;#element-key">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-keyref"><code>keyref</code>:
          [<specref ref="ref30"/>]
          [<xspecref href="&part1;#element-keyref">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-length"><code>length</code>:
          [<specref ref="ref12"/>]
          [<xspecref href="&part2;#element-length">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-list"><code>list</code>:
          [<specref ref="ref45"/>]
          [<xspecref href="&part2;#element-list">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-maxInclusive"><code>maxInclusive</code>:
          [<specref ref="ref8"/>]
          [<xspecref href="&part2;#element-maxInclusive">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-maxLength"><code>maxLength</code>:
          [<specref ref="ref12"/>]
          [<xspecref href="&part2;#element-maxLength">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-minInclusive"><code>minInclusive</code>:
          [<specref ref="ref8"/>]
          [<xspecref href="&part2;#element-minInclusive">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-minLength"><code>minLength</code>:
          [<specref ref="ref12"/>]
          [<xspecref href="&part2;#element-minLength">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-pattern"><code>pattern</code>:
          [<specref ref="ref9"/>]
          [<xspecref href="&part2;#element-pattern">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-redefine"><code>redefine</code>:
          [<specref ref="ref52"/>]
          [<xspecref href="&part1;#element-redefine">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-restriction"><code>restriction</code>:
          [<specref ref="ref7"/>]
          [<xspecref href="&part2;#element-restriction">Datatypes</xspecref>],
          [<specref ref="ref54"/>]
          [<xspecref href="&part1;#element-restriction">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-schema"><code>schema</code>:
          [<specref ref="ref1"/>]
          [<xspecref href="&part1;#element-schema">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-selector"><code>selector</code>:
          [<specref ref="ref29"/>]
          [<xspecref href="&part1;#element-selector">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-sequence"><code>sequence</code>:
          [<specref ref="ref17"/>]
          [<xspecref href="&part1;#element-sequence">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-simpleContent"><code>simpleContent</code>:
          [<specref ref="ref37"/>]
          [<xspecref href="&part1;#element-simpleContent">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-simpleType"><code>simpleType</code>:
          [<specref ref="ref7"/>]
          [<xspecref href="&part2;#element-simpleType">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-union"><code>union</code>:
          [<specref ref="ref46"/>]
          [<xspecref href="&part2;#element-union">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td id="element-unique"><code>unique</code>:
          [<specref ref="ref29"/>]
          [<xspecref href="&part1;#element-unique">Structures</xspecref>]</td>
        </tr>
      </tbody>
    </table>
    </div2>
    <div2 id="indexAttr"><head>XML Schema Attributes</head>
    <p>Each attribute name is
      followed by one or more pairs of references. Each pair of
      references consists of a link to an example in the Primer,
      plus a link to a formal XML description in either the
      Structures or Datatypes parts of the XML Schema
      specification.
    </p>
    <table cellspacing="3" cellpadding="3">
      <tbody>
        <tr>
          <td id="attribute-abstract"><code>abstract</code>:
          <loc href="#ref26">element declaration</loc>
          [<xspecref href="&part1;#element-element">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td><code>abstract</code>:
          <loc href="#ref26">complex type definition</loc>
          [<xspecref href="&part1;#element-complexType">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-attributeFormDefault"><code>attributeFormDefault</code>:
          <loc href="#ref50">schema definition</loc>
          [<xspecref href="&part1;#element-schema">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-base"><code>base</code>:
          <loc href="#ref8">simple type definition</loc>
          [<xspecref href="&part2;#element-simpleType">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td><code>base</code>:
          <loc href="#ref37">complex type definition</loc>
          [<xspecref href="&part1;#element-complexType">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-block"><code>block</code>:
          <loc href="#ref28">complex type definition</loc>
          [<xspecref href="&part1;#element-complexType">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-blockDefault"><code>blockDefault</code>:
          <loc href="#ref42">schema definition</loc>
          [<xspecref href="&part1;#element-schema">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-attr-default"><code>default</code>:
          <loc href="#ref36">attribute declaration</loc>
          [<xspecref href="&part1;#element-attribute">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-default"><code>default</code>:
          <loc href="#ref36">element declaration</loc>
          [<xspecref href="&part1;#element-element">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-elementFormDefault"><code>elementFormDefault</code>:
          <loc href="#ref50">schema definition</loc>
          [<xspecref href="&part1;#element-schema">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-final"><code>final</code>:
          <loc href="#ref27">complex type definition</loc>
          [<xspecref href="&part1;#element-complexType">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-finalDefault"><code>finalDefault</code>:
         <loc href="#ref43">schema definition</loc>
          [<xspecref href="&part1;#element-schema">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-attr-fixed"><code>fixed</code>:
          <loc href="#ref55">attribute declaration</loc>
          [<xspecref href="&part1;#element-attribute">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-fixed"><code>fixed</code>:
          <loc href="#ref55">element declaration</loc>
          [<xspecref href="&part1;#element-element">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-facet-fixed"><code>fixed</code>:
          <loc href="#ref44">simple type definition</loc>
          [<xspecref href="&part2;#rf-facets">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-form"><code>form</code>:
          <loc href="#ref39">attribute declaration</loc>
          [<xspecref href="&part1;#element-attribute">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td><code>form</code>:
          <loc href="#ref39">element declaration</loc>
          [<xspecref href="&part1;#element-element">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-itemType"><code>itemType</code>:
          <loc href="#ref45">list type definition</loc>
          [<xspecref href="&part2;#element-list">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-memberTypes"><code>memberTypes</code>:
          <loc href="#ref46">union type definition</loc>
          [<xspecref href="&part2;#element-union">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-maxOccurs"><code>maxOccurs</code>:
          <loc href="#ref6">element declaration</loc>
          [<xspecref href="&part1;#element-element">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-minOccurs"><code>minOccurs</code>:
          <loc href="#ref6">element declaration</loc>
          [<xspecref href="&part1;#element-element">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-mixed"><code>mixed</code>:
          <loc href="#ref51">complex type definition</loc>
          [<xspecref href="&part1;#element-complexType">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-name"><code>name</code>:
          <loc href="#ref3">element declaration</loc>
          [<xspecref href="&part1;#element-element">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td><code>name</code>:
          <loc href="#ref2">attribute declaration</loc>
          [<xspecref href="&part1;#element-attribute">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td><code>name</code>:
          <loc href="#ref2">complex type definition</loc>
          [<xspecref href="&part1;#element-complexType">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td><code>name</code>:
          <loc href="#ref8">simple type definition</loc>
          [<xspecref href="&part2;#element-simpleType">Datatypes</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-namespace"><code>namespace</code>:
          <loc href="#ref34">element wildcard</loc>
          [<xspecref href="&part1;#element-any">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td><code>namespace</code>:
          <loc href="#ref31">import specification</loc>
          [<xspecref href="&part1;#element-include">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-noNamespaceSchemaLocation"><code>xsi:noNamespaceSchemaLocation</code>:
          <loc href="#ref40">instance element</loc>
          [<xspecref href="&part1;#schema-loc">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-xsinil"><code>xsi:nil</code>:
          <loc href="#ref21">instance element</loc>
          [<xspecref href="&part1;#xsi_nil">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-nillable"><code>nillable</code>:
          <loc href="#ref20">element declaration</loc>
          [<xspecref href="&part1;#element-element">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-processContents"><code>processContents</code>:
          <loc href="#ref33">element wildcard</loc>
          [<xspecref href="&part1;#element-any">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td><code>processContents</code>:
          <loc href="#ref35">attribute wildcard</loc>
          [<xspecref href="&part1;#element-anyAttribute">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-ref"><code>ref</code>:
          <loc href="#ref5">element declaration</loc>
          [<xspecref href="&part1;#element-element">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-schemaLocation"><code>schemaLocation</code>:
          <loc href="#ref23">include specification</loc>
          [<xspecref href="&part1;#element-include">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td><code>schemaLocation</code>:
          <loc href="#ref52">redefine specification</loc>
          [<xspecref href="&part1;#element-redefine">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td><code>schemaLocation</code>:
          <loc href="#ref41">import specification</loc>
          [<xspecref href="&part1;#element-import">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-xsischemaLocation"><code>xsi:schemaLocation</code>:
          <loc href="#ref40">instance element</loc>
          [<xspecref href="&part1;#xsi_schemaLocation">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-subsGroup"><code>substitutionGroup</code>:
          <loc href="#ref25">element declaration</loc>
          [<xspecref href="&part1;#element-element">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-targetNamespace"><code>targetNamespace</code>:
          <loc href="#ref56">schema definition</loc>
          [<xspecref href="&part1;#element-schema">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-type"><code>type</code>:
          <loc href="#ref4">element declaration</loc>
          [<xspecref href="&part1;#element-element">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td><code>type</code>:
          <loc href="#ref4">attribute declaration</loc>
          [<xspecref href="&part1;#element-attribute">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-xsitype"><code>xsi:type</code>:
          <loc href="#ref24">instance element</loc>
          [<xspecref href="&part1;#xsi_type">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-use"><code>use</code>:
          <loc href="#ref36">attribute declaration</loc>
          [<xspecref href="&part1;#element-attribute">Structures</xspecref>]</td>
        </tr>
        <tr>
          <td id="attribute-xpath"><code>xpath</code>:
          <loc href="#ref29">identity constraint definition</loc>
          [<xspecref href="&part1;#declare-key">Structures</xspecref>]</td>
        </tr>
      </tbody>
    </table>

    <p>XML Schema's simple types are described in <loc href="#simpleTypesTable">Table 2</loc>.
    </p>
    </div2>
   </div1>
  </back>
</spec>
